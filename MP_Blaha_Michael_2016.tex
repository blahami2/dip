% % % % % % % % % % % % %
% Example thesis (\glref{CTU} FIT) based on \glref{CTU}style 
% use: pdfcsplain <FIT-ZP.tex>
% write this document as UTF-8
% % % % % % % % % % % % %
% \glref{CTU}style: see more at http://petr.olsak.net/ctustyle.html
% requirements: ctustyle.tex, ctulogo.pdf
% \glref{CTU}style requires OPmac (opmac.tex)
% download OPmac from
% http://petr.olsak.net/opmac.html
% % % % % % % % % % % % %

% This example created by Ondrej Guth <ondrej.guth@fit.cvut.cz> 2014
% based on \glref{CTU}style by Petr Olsak

% % % % % % % % % % % % % 
% The following not to be modified
% % % % % % % % % % % % % 
\input ctustyle
\input opmac-bib

\faculty {F8}
% % % % % % % % % % % % % 
% Modify the~following
% % % % % % % % % % % % %

% (thesis type {B,M,D})/(language {CZ,EN})
\worktype [M/EN]
\department {Department of Software Engineering}
\title {Tablet infotainment system}
\author {Bc. Michael Bl\' aha}
\date {January 2016}
\supervisor{Ing. Jan \v Sediv\' y, CSc.}
\abstractEN {
The goal of this thesis is to design a graphical user interface for {in-car} tablet usage, which will minimize the cognitive load and still offer the required functionality. Next goal is to develop a tablet application using this GUI and displaying the information obtained from a car via OBD. Final goal is to test the tablet application in a suitable environment.
}
\abstractCZ {
C\' ilem t\' eto pr\' ace je navrhnout grafick\' e u\v zivatelsk\' e rozhran\' i pro pou\v zit\'i tabletu v automobilu, kter\' e minimalizuje kognitivn\' i z\' at\v e\v z a p\v ritom poskytne po\v zadovanou funkcionalitu. Dal\v s\' im c\' ilem je s pou\v zit\' im tohoto GUI vyvinout tabletovou aplikaci, kter\' a umo\v zn\' i zobrazen\' i informac\' i obdr\v zen\' ych z automobilu pomoc\' i OBD. Posledn\' im c\' ilem je otestovat tabletovou aplikace ve vhodn\' em prost\v red\' i.
}
\declaration {I hereby declare that the presented thesis is my own work and that I have cited all sources of information in accordance with the Guideline for adhering to ethical principles when elaborating an academic final thesis.
		
		I acknowledge that my thesis is subject to the rights and obligations stipulated by the Act No.~121/2000 Coll., the Copyright Act, as amended. In accordance with Article~46(6) of the Act, I hereby grant a nonexclusive authorization (license) to utilize this thesis, including any and all computer programs incorporated therein or attached thereto and all corresponding documentation (hereinafter collectively referred to as the ``Work''), to any and all persons that wish to utilize the Work. Such persons are entitled to use the Work in any way (including for-profit purposes) that does not detract from its value. This authorization is not limited in terms of time, location and quantity.
		
Prague, 12th January 2016 \signature

%\hfil\break\hfil\break\hfil\break\hfil\break\hfil\break

%Prohla\v suji, \v ze jsem p\v redlo\v zenou pr\'aci vypracoval(a) samostatn\v e a \v ze jsem uvedl(a) ve\v sker\'e pou\v zit\'e informa\v cn\'\i{} zdroje v~souladu s~Metodick\'ym pokynem o~etick\'e p\v r\'\i{}prav\v e vysoko\v skolsk\'ych z\'av\v ere\v cn\'ych prac\'\i{}.
%
%		Beru na v\v edom\'\i{}, \v ze se na moji pr\'aci vztahuj\'\i{} pr\'ava a povinnosti vypl\'yvaj\'\i{}c\'\i{} ze z\'akona \v c.~121/2000~Sb., autorsk\'eho z\'akona, ve zn\v en\'\i{} pozd\v ej\v s\'\i{}ch p\v redpis{\r u}. V~souladu s~ust. \S{}~46 odst.~6 tohoto z\'akona t\'\i{}mto ud\v eluji nev\'yhradn\'\i{} opr\'avn\v en\'\i{} (licenci) k~u\v zit\'\i{} t\'eto moj\'\i{} pr\'ace, a to v\v cetn\v e v\v sech po\v c\'\i{}ta\v cov\'ych program{\r u}, je\v z jsou jej\'\i{} sou\v c\'ast\'\i{} \v ci p\v r\'\i{}lohou a ve\v sker\'e jejich dokumentace (d\'ale souhrnn\v e jen \uv{D\'\i{}lo}), a to v\v sem osob\'am, kter\'e si p\v rej\'\i{} D\'\i{}lo u\v z\'\i{}t. Tyto osoby jsou opr\'avn\v eny D\'\i{}lo u\v z\'\i{}t jak\'ymkoli zp{\r u}sobem, kter\'y nesni\v zuje hodnotu D\'\i{}la a za jak\'ymkoli \'u\v celem (v\v cetn\v e u\v zit\'\i{} k~v\'yd\v ele\v cn\'ym \'u\v cel{\r u}m). Toto opr\'avn\v en\'\i{} je \v casov\v e, teritori\'aln\v e i mno\v zstevn\v e neomezen\'e.
%
%V Praze dne 12. ledna 2016 \signature
}

\keywordsEN {%
%\rfc{KeywordsEN}
Android, Java, OBD, GUI, car, LCT, A/B testing, usability testing
}
\keywordsCZ {%
%\rfc{KeywordCZ}
Android, Java, OBD, GUI, auto, LCT, A/B testov\' an\' i, testov\' an\' i pou\v zitelnosti
}
\thanks {           % Use main language here
I would like to express my gratitude to my master thesis supervisor, Ing.~Jan~\v Sediv\' y,~CSc., for his support, time and valuable advice.

 I am also deeply grateful to the Department of Vehicle Technology, Faculty of Transportation Sciences, CTU for all the help and patience with testing and everything related. 
 
I would also like to thank my college, Bc. Luk\' a\v s Hrub\' y for cooperation and advice.

This work was partially supported by CZECH TECHNICAL UNIVERSITY MEDIA LABORATORY and I am grateful for that as well.
}

\specification{\picw=\hsize \cinspic images/specification_v2.png }

\picw=.9\hsize
\sdef{item:p}{ $+$ }
\sdef{item:m}{ $-$ }

%TODO
%\draft

\input glosdata

\makefront

%----------------------------------------------------------------------- INTRODUCTION ------------------------------------------------------------------------%
\label[introduction]
\chap Introduction 

%\rfc{Introduction}
%
%sources:
%\begitems
%* \url{https://docs.google.com/document/d/1pGtlS5uY4PdKfHjf83dFGrajyVcea0tvzAnwXf61Cs8/edit}
%* generally progress: \url{https://docs.google.com/document/d/1CEWym7MphsCO0v3CXe_bTHOgFBgquBbPVbhk_pHZ5t8/edit}
%\enditems


%		------------------------------------------------------------------------ Motivation ----------------------------------------------------------------------%
\label[introduction.motivation]
\sec Motivation 

In~the~modern era of~portable electronic devices people use these devices daily. Unfortunately, even when it is inappropriate -- for example in~cars during driving. Such usage can easily cause safety hazards and often they actually do\fnote{\url{http://www.dailymail.co.uk/news/article-2591148/One-four-car-accidents-caused-cell-phone-use-driving-five-cent-blamed-texting.html}~\cite[Gorman2014]}. This situation calls despe\-rately for~a~proper solution. As the~usage of~these~devices is forbidden while driving and yet drivers still use them, a~prohibition is not the~solution. And when people do~not adapt, the~environment has to. While we cannot change the~way of~transportation, we can change the~way of~controlling these devices. Therefore an~application will be made, trying to solve this issue and helping the~driver do all the~tasks he wants to do, but in~a~safe way without endangering the~driver himself and everybody else who might get hurt in~a~possible accident.


%	------------------------------------------------------------------------ Project ----------------------------------------------------------------------%
\label[introduction.project]
\sec Project

The goal of this project is to create an~application that will enable users to use their android tablet safely while driving. In addition to focusing on usability and minimizing the~cognitive load, this application should offer rich variety of use cases in a~simple but attractive design. For the~purpose of this project, this application will be referred to as ``CarDashboard''.

First step in the project is reviewing existing applications, as it is essential for better insight and inspiration. Designing a proper user interface will follow. To design a user interface for a car environment is not a simple task, because it is the main mean of interaction with the driver, it's quality is the most important factor in driver's distraction when controlling the application. After designing the \glref{GUI}, an application will be developed implementing the given \glref{GUI}. It will enable the driver to communicate with car (currently using read-only operations) via \glref{OBD}. After the development process, the application will be properly tested using a car simulator. The tests will be thoroughly evaluated using various evaluation methods.

\par\maybebreak 3.5cm
%	------------------------------------------------------------------------ Assignment analysis ----------------------------------------------------------------------%
\label[introduction.assignment_analysis]
\sec Assignment analysis

\secc Assignment tasks

\seccc Review existing Android applications for in-car use

One of the~key approaches in research project is reviewing the~existing progress in the~given field. Reviewing existing applications helps to understand the~topic, see the~bigger picture, learn from mistakes of others and last but not least, to get a general idea about competition.

\seccc Review and analyze User Interface development methods for in-car infotainment applications

Considering the~car environment, the~user interface must deal with a~lot more problems than usual. This task will review existing User Interface development rules and apply them to the~car environment, then analyze them and choose a proper method for car-\glref{UI} design process.

\seccc Analyze the~in-car OBD API and exported data

On-Board Diagnostics \glref{API} is a~standard \glref{API} provided by modern cars for gathering various information, such as speed or engine temperature. This task focuses on understanding and gathering data from the~\glref{OBD} \glref{API}.

\seccc Design an~application system architecture for accessing the~OBD data and resources

Having the~data from \glref{OBD} and preparing an~application for displaying them, designing a proper architecture is required for everything to work well. The application has to gather data and display them properly without unnecessary delay.

\seccc Design a~tablet User Interface for in-car use

After reviewing existing applications and \glref{UI} development methods, the~next goal is to create new User Interface for in-car use, while considering the~constraints this environment puts on it.

\seccc Design and implement in-car application offering the~OBD data for Android tablet platform

With everything prepared and thought through, the~application will be developed based on result from all the~tasks accomplished so far. In this case, the~Android platform will be used, as explained later in the~text.

\seccc Perform UI and application testing and evaluate results

For best results the~application must and will be tested. Both code and \glref{UI} must be tested properly, using various testing approaches, such as unit tests or usability testing with real users in a~car simulator.

%------------------------------------------------------------------------ ANALYSIS ------------------------------------------------------------------------%
\label[analysis]
\chap Analysis

This chapter is about the~process of analyzing resources, researches, tools and project related areas. It contains research about existing related applications, possible application platforms and a~description of the~chosen platform in a more detailed way. It also presents a~basic insight into \glref{GUI} design process as well as general \glref{GUI} principles and \glref{GUI} specifics for the~car environment. Then the~application idea is described from the point of~view of use-cases and tasks followed by the~review of tools used for development. Finally the~\glref{OBD} is described with it's \glref{API} and the~data it provides.

%	------------------------------------------------------------------------ Existing applications ----------------------------------------------------------------------%
\label[analysis.existing_applications]
\sec Existing applications

An important step in developing a~new application is checking related applications (if they exist) for valuable information to learn from. Based on applications listed in an~article\fnote{\url{http://www.makeuseof.com/tag/5-best-dashboard-car-mode-apps-android-compared/}}, multiple applications are reviewed and analyzed, listing their advantages and disadvantages.

\label[analysis.existing_applications.torque]
\secc Torque 

Torque\fnote{available from \url{https://play.google.com/store/apps/details?id=org.prowl.torquefree&hl=en}} can actually show almost anything that \glref{OBD} (described in section \ref[analysis.obd] on page \pgref[analysis.obd]) provides. It is currently the most downloaded application from all the listed applications.

Starting with an~empty screen, a lot of settings are required before using this application since there is no default mode. Adding new views is intuitive, but the add menu lacks hierarchy and everything is just a list of various options. There is no cancel button when popping the~menu dialog. Several kinds of displays are supported, but it is hard to tell by their names. Responsiveness it not smooth at all and launching the~application in a horizontal mode is confusing, as everything behaves like if it was in a vertical mode.


\medskip
\centerline{
\clabel[analysis.existing_applications.torque.img]{Screenshot from Torque}
\inspic images/analysis_app_torque.png }\nobreak\medskip
\caption/f Screenshot from Torque

\seccc Advantages

\begitems
* High amount of data from \glref{OBD} available,
* various layout settings and themes,
* \glref{HUD} mode.
\enditems

\seccc Disadvantages

\begitems
* One-level confusing menu without hierarchy,
* limited size options for displays (3 types),
* lacks default mode with predefined displays,
* hard to place displays, the~grid does not work well,
* slow and unresponsive.
\enditems

% screenshot

\label[analysis.existing_applications.carhome_ultra]
\secc CarHome Ultra 

CarHome Ultra\fnote{available from \url{https://play.google.com/store/apps/details?id=spinninghead.carhome&hl=en}} appears to be just a~simple application offering speed, compass, weather and external application launcher. New version also displays a location (an address) and a~phone version is able to reply to text messages. It also supports text-to-speech feature (on touch).

The application starts with a~pop-up tutorial for it's elementary functionality, telling the~user about a~speedometer, a compass, a weather forecast and a customizable dashboard for launching external applications. In default it offers Google Maps, Google Navigation and a voice search. Adding another external application shortcut is done by tapping the~tab. There are also some basic settings, which offer brightness mode (day, night, auto), theme and safety options.



\medskip
\centerline{
\clabel[analysis.existing_applications.carhome_ultra.img]{Screenshot from CarHome Ultra}
\inspic images/analysis_app_carhomeultra.png }\nobreak\medskip
\caption/f Screenshot from CarHome Ultra

\seccc Advantages

\begitems
* Simple \glref{UI}, easy to understand,
* responsive, fluent,
* possible to change units (mile/km, etc.),
* lot of themes available,
* adjustable update rates,
* a~lot of different settings.
\enditems

\seccc Disadvantages

\begitems
* Small buttons on small screens (fixed amount of (six) buttons),
* even smaller setting buttons,
* limited functionality,
* tapping weather makes the~app speak for every single tap, no matter if it already speaks (it can speak for hours after a lot of taps).
\enditems

\label[analysis.existing_applications.car_dashdroid]
\secc Car Dashdroid 

Car Dashdroid\fnote{available from \url{https://play.google.com/store/apps/details?id=com.nezdroid.cardashdroid&hl=en}} is another similar application providing basic information and functionality. It also provides settings for Bluetooth communication, brightness, screen rotation, full-screen, day/night mode and application settings, where other options can be set, such as home address, theme, units, etc.

After a~long on-load time of the~application, a~main window appears. It has three screens which change by swiping right or left. The left screen contains a dial keyboard, the~right screen contains customizable cards (for external application shortcuts or built-in tools) and the~main screen consists of weather, speed and shortcuts to contacts, music, navigation and voice commands.

\medskip
\centerline{
\clabel[analysis.existing_applications.cardashdroid.img]{Screenshot from Car Dashdroid}
\inspic images/analysis_app_cardashdroid.png }\nobreak\medskip
\caption/f Screenshot from Car Dashdroid

\seccc Advantages

\begitems
* Simple \glref{UI}, easy to understand,
* responsive, fluent,
* possible to change units (mile/km, etc.),
* able to read incoming \glref{SMS} using \glref{TTS}.
\enditems

\seccc Disadvantages

\begitems
* Very limited functionality,
* not optimized for a tablet,
* distractive commercial ads in a free version.
\enditems

\label[analysis.existing_applications.ultimate_car_dock]
\secc Ultimate Car Dock 

While the~design is very similar to CarHome Ultra, Ultimate Car Dock\fnote{available from \url{https://play.google.com/store/apps/details?id=com.appsontoast.ultimatecardock&hl=en}} offers fewer displays on a~single screen. There are five screens, each one consists of six cards. Every card can change into shortcut or a~build-in application. The Ultimate Car Dock has only few built-in applications: music player, voice command, speed, weather, messages and calls. It also supports shortcuts to other applications.

\medskip
\centerline{
\clabel[analysis.existing_applications.ultimatecardock.img]{Screenshot from Ultimate Car Dock}
\inspic images/analysis_app_ultimatecardock.png }\nobreak\medskip
\caption/f Screenshot from Ultimate Car Dock

\seccc Advantages

\begitems
* Simple \glref{UI}, easy to understand,
* responsive, fluent,
* possible to change units (mile/km, etc.),
* able to read various incoming notifications using \glref{TTS} (Gmail, WhatsApp, etc.),
* predefined \glref{SMS} responses (selectable when a~message comes),
* direct calls and messages (shortcut to call/message a~certain person).
\enditems

\seccc Disadvantages

\begitems
* Limited functionality,
* not optimized for a tablet,
* small text font.
\enditems

\label[analysis.existing_applications.conclusion]
\secc Conclusion 

Except by Torque, which focuses mainly (and only) on \glref{OBD}, all the~applications are very similar to each other. They have similar design and functionality -- mostly weather, speed provided by GPS, a voice command feature and shortcuts for external applications.

\seccc Suggestions

\begitems
* \glref{OBD} support,
* shortcuts to other applications,
* adjustable cards,
* built-in cards (weather, speed, voice command, etc.),
* simple grid-based \glref{UI},
* possibility to change displayed units,
* responsive and fluent,
* day and night theme,
* predefined message and call responses,
* \glref{TTS} for incoming notifications.
\enditems

\seccc Possible issues to avoid

\begitems
* Slow responsiveness,
* limited functionality,
* small and hardly visible font,
* distractive ads.
\enditems

\label[analysis.existing_applications.android_auto]
\secc Android Auto 

Recently, Google Inc. presented new application model for information delivery while driving~\cite[AndroidAuto]. It is called Android Auto and it provides a~standardized user interface and user interaction model for Android devices. Focusing on minimizing the~driver distraction, it presents a~few options to interact with a user. It supports three application types:
\begitems
* System overview,
* audio applications,
* messaging applications.
\enditems

\seccc System overview

System overview is supposed to be a~home screen for an Android Auto application. It presents both current and past notifications. The amount of notifications is limited based on screen size. Every notification consists of an~intent icon, a text and an image, while following certain sizing rules. Every such notification can be expanded on the~spot or another sub-application can be launched.

\medskip
\centerline{
\clabel[analysis.existing_applications.aa.overview]{Android Auto Home screen}
\inspic images/analysis_aa_overview.png }\nobreak\medskip
\caption/f Android Auto Home screen

\seccc Audio applications

Audio applications in Android Auto have a~simple template structure. It consists of a~main consumption view, a~drawer and a~queue screen. The main consumption view displays a~few control elements and a~cover background. The drawer is a~simple list and provides access to favorite and popular content. Finally the~queue screen displays a~list of pending content (for example songs in a~queue).

\medskip
\centerline{
\clabel[analysis.existing_applications.aa.audio]{Android Auto Audio application}
\inspic images/analysis_aa_audio.png }\nobreak\medskip
\caption/f Android Auto audio application

\seccc Messaging applications

Focusing on minimizing the~cognitive load, messaging concept in Android Auto prefers voice control to looking and typing. It allows reading the~message out-loud and responding with a~set of predefined voice commands as well as dictating a~whole message using a built-in speech recognition.

\medskip
\centerline{
\clabel[analysis.existing_applications.aa.message]{Android Auto conversational flow}
\inspic images/analysis_aa_message.png }\nobreak\medskip
\caption/f Android Auto conversational flow

\seccc Conclusion

It seems to be a~good sign that even Google Inc. is interested in this area and performs such a~research. Every Android application can be designed for Android Auto and use it's simplified user interface, allowing the~developer to focus on other issues than in-car user interaction. However, the~functionality is currently very limited. Hopefully there will be further progress soon.

%	------------------------------------------------------------------------ Platforms ----------------------------------------------------------------------%
\label[analysis.platforms]
\sec Platforms

The chosen platform heavily influences market share an~application can reach. Therefore, only platforms with a solid market share are considered. Another criteria is a~simplicity of development, which influences the~time and effort put into an~application before it can be released. This is especially important for finding out the~sale potential of an~application quickly.

Following the~first rule mentioned above and based on tablet sales in past years~\cite[Lunden2014], the~only viable options for an~application are platforms Android, iOS and Windows, since other platforms did not score high results.

\label[analysis.platforms.android]
\secc Android

In 2013, the~Android platform had 61.9 \% market share~\cite[Lunden2014], making it the~most used platform in the~world. Targeting the~Android platform creates a large base of potential customers.

The development language for Android is Java, commonly known object-oriented programming language with a solid developer base. Therefore it is easy to find developers as well as answers to variety of programming related issues, making the~development easier.

\label[analysis.platforms.ios]
\secc iOS

With 36 \% market share in 2013~\cite[Lunden2014], iOS is the~second most popular tablet platform. Considering a~typical iOS user who is willing to pay for quality, iOS could be a~good choice for an~application in context of potential customers.

However, the~development language called Swift is somewhat new in the~world, which brings a~lot of possible difficulties. Searching for answers while developing in this technology might prove to be too troublesome.

\label[analysis.platforms.windows]
\secc Windows

With only 2.1 \% market share in 2013~\cite[Lunden2014], the~Windows platform does not seem to be a~valid choice for given criteria. Having thirty times lower customer base than Android, it goes into the~nice-to-have section when it comes to multi-platform applications.

\label[analysis.platforms.conclusion]
\secc Conclusion

Fulfilling the~requirements for customer base as well as simplicity of development, the~Android platform seems to be the~best choice available at the~time of writing this thesis. As such, it will be analyzed more thoroughly later in this chapter (\ref[analysis.android_platform]).

%	------------------------------------------------------------------------ Android platform ----------------------------------------------------------------------%
\label[analysis.android_platform]
\sec Android platform

There are some platform aspects to be considered when developing for Android-based tablet device. First is a~problem which is present with most of the~tablet devices today -- the~device performance. While the~hardware is continuously evolving, one must consider older devices as well as growing requirements for graphical presentation. The second possible issue is the~Android architecture, which influences the~inner communication throughout an application.~\cite[AndroidDevelopers]

\label[analysis.android_platform.performance]
\secc Performance

Nearly with every new version of Android, new presentation effects are prepared for developers to use. While it is not mandatory, it is still advised to hold the~platform standards as the~market demands it. An application must have a~good look and feel in order to attract attention. This must be considered when creating an~application, because the~environment demands fluent responses.

\label[analysis.android_platform.architecture]
\secc Architecture

The main building block in Android application is an~Activity. The Activity is an~independent component of an application, a~hybrid between a controller and a view in \glref{MVC} architecture. It contains a~single screen (which contains a~single layout), it has it's own independent data. An application usually consists of multiple loosely coupled Activities. Those Activities are held in an~Activity stack, where they are preserved to be used later without need to create them all over again. However, if the~system needs memory, it clears the~stack from the~bottom (least recently used Activities).

Serving for communication between Activities there are so called Intents. An Intent is a~main concept of communication between two components. A~component can be for example an~Activity or a~Service. Intent can contain simple data such as primitive or serialized data.

Presentation is handled using XML layout descriptors, which contain information about View objects and their parameters. This feature allows to separate the~actual code from a~layout creation, which could help the front-end designers create a~\glref{GUI} without having to understand the~Java language or the~Android \glref{API}.

\glref{XML} is not used just for layouts. Most of the~resources are defined using \glref{XML} descriptors. There are strings, values, dimensions and even certain graphical objects defined using \glref{XML}. These resources are accessible from code using a static class {\tt R}, which is created during build time by most build system automatically.

As a~relatively new concept, a new element called Fragment was created. It is similar to the Activity, however it is not a~mandatory component. It can be used as a~controller for a certain functionality area. It's advantage is that a~developer can create separate Fragments with separate area of concern and display one or many of these based on the~screen size. The typical use-case example can be a~list of items and a~detail of a~selected item. On small screens two Activities, containing a~single Fragment each, will be needed, while on larger screens one Activity can contain both Fragments.

\label[analysis.android_platform.material_design]
\secc Material design

Material design is a visual language created by Google Inc. It is inspired by a real material, it's behavior in motion, the effects of light and dark, the rules of physics. It also describes colors, which should please the eye and create meaning and focus. The usage of this language is described in Material design guidelines~\cite[MaterialDesign].

Every material has certain properties. Every element is considered to be a real object with it's depth and it's position in the 3D space. This causes a lighting to create shadows based on an elevation, to distinguish between layers, to show distance of elements.

Material design guidelines also describe animations considering the mass and weight of animated objects, responses to interaction, also the physical laws of motion in acceleration and deceleration, in jumping up and falling down.

Apart from these general descriptions of material and motion, it also states certain rules and exact measurements. For example, lists should be scrollable vertically and fluently. Buttons, icons, fonts and all the other elements should be of certain sizes. Views should choose from a certain set of layouts. Layouts for lists, cards, buttons and so on are all specified in the guidelines.

%------------------------------------------------------------------------ GUI ----------------------------------------------------------------------%
\label[analysis.gui]
\sec GUI


\label[analysis.gui.basic_principles]
\secc Basic principles

As the~main tool of communication between an~application and it's user, user interface must follow one basic rule -- the~user goes first. \glref{UI} is about the~user, he must have a~good feeling when using the~application. He must understand what to do and how to do it. Therefore there are four rules that a~proper \glref{UI} must obey~\cite[Zikovsky2015]:
\begitems
* {\bf Clear} -- it must be obvious what and where the~user can control,
* {\bf effective} -- minimizing required user interactions for a certain (requested) thing to happen,
* {\bf foolproof} - avoiding errors before they happen,
* {\bf pleasant} - no stress when working with the~\glref{UI}, pleasant colors, a contrast, a good readability.
\enditems

Those rules might seem too shallow. That is why there are certain subgoals which are more specific, helping to achieve the~main four goals. Those subgoals are the~following seven:
\begitems
* {\bf Minimality} -- removing everything that can be removed without losing a~requested information value,
* {\bf responsiveness} -- giving the~user a~proper feedback so that he knows something is happening,
* {\bf forgiveness} -- letting the~user make mistakes, allowing him to fix them (for example undo button or prompt message),
* {\bf familiarity} -- using familiar, commonly used metaphors, icons, procedures,
* {\bf consistency} -- using a consistent visual and interaction language,
* {\bf integration} -- using platform specific elements and rules
* {\bf simplicity} - allowing the user to quickly learn how to use the~\glref{UI}
\enditems

%sources:
%\begitems
%* MI-NUR \url{https://edux.fit.cvut.cz/courses/MI-NUR/lectures/start}
%* Designing for indash automotive \url{http://revinity.com/?p=128 }
%* UX design stackexchange \url{http://ux.stackexchange.com/questions/51968/what-ux-guidelines-should-one-keep-in-mind-when-designing-the-gui-for-a-automobi}         0
%\enditems

\label[analysis.gui.ui_in_a_car_environment]
\secc UI in a~car environment

When developing a user interface for a car, certain responsibility is added. The need of safety while using the~\glref{UI} becomes a~main priority. Because of that, some aspects are more important than others~\cite[Heaton2013]. The most important aspects are described later in this section.

\seccc Minimality

For minimizing the~cognitive load, there must be as little information as possible at a~certain time. A user must see what he wants to see on first sight without seeking the~answer for too long. When minimizing the~information displayed, there is no confusion, which minimizes the~glance time.

\seccc Consistence

Supporting usability and shortness of learning curve, consistence allows a user to remember one procedure and apply it successfully in different sections of \glref{UI}. It allows user to learn things just once.

\seccc Readability

Good readability is one of the~conditions for an application to be pleasant to use. In case of a car environment, however, the~readability of information is not just pleasant but also critical. Allowing the~user to see the~information he needs to see in the~shortest time possible is fatal when it comes to driving. Therefore the~text font has to be large enough for every driver to recognize it.

\seccc Controls

When it comes to controlling an~application in an~environment such as car, it is required to consider certain aspects that are not present in other environments. The moving car prevents user from being precise when it comes to touch. Therefore controls must be large enough to be reliably reachable. 

\seccc Colors

While in other environments a~user can usually control a~device brightness, it is not as easy task while driving. Furthermore, blinding the~user with too much light might be fatal. Therefore proper colors must be used. For example, dominance of white color might be visible well in the~daylight, but might blind the~user at the~night time. Also, proper color contrast must be considered for good a visibility and readability.

\seccc Responsiveness

Responsiveness is an~important factor when it comes to pleasure of using an~application, but when it comes to using it in a~car, it becomes extremely important for safety as well. When an~application is responsive, it's user does not have to check the~screen for progress so often or worse, wait for the~progress looking at it continuously.

\label[analysis.gui.development_process]
\secc Development process

The \glref{GUI} development process is a~part of a~bigger process -- the~User Interface development process. As the~decision has already been made to create a~graphical user interface, development methods for other types of user interface will not be described.

The basic procedure of creating a~\glref{UI} design consists of multiple steps~\cite[Zikovsky2015_2]. Fulfilling requirements for each step properly should guarantee a~proper outcome. The \glref{UI} design steps are as follows:
\begitems
* Assignment and understanding,
* research,
* behaviour specification,
* basic vision (mockup),
* detailed design of the~looks,
* implementation,
* usability testing,
* evaluation,
* final implementation.
\enditems

The process can also be divided into fewer phases, from which each contains multiple tasks. The list mentioned above is divided into these phases, so that these phases are certain sets of steps that can be iterated over and over for the~best result possible. These phases are the~lo-fi phase, the~hi-fi phase and the~final phase.

\par\maybebreak 1.5cm
\seccc Lo-fi phase

\begitems
* Basic product statement,
* needs assessment,
* use case brainstorming,
* task list definition,
* task analysis,
* prototyping,
* evaluation,
\begitems
  * cognitive walk-through,
  * collaborative critiquing,
  * heuristic evaluation,
\enditems
* re-design.
\enditems

The product statement should state what the~product is, what it does and who is it for. This ensures that the~developer knows what is he actually trying to achieve and why. Also, it briefly describes a~target user group.

The needs assessment is a~systematic process for determining and addressing the~needs. It is not necessary to perform unless the~goal or the~user group is unknown. It also involves a user research.

The use-case brainstorming is used for finding the~use-cases of the~application. In other words, the~outcome should be a set of use-cases, of things user can do with the~application. It also gives an~idea about functionality, not just the~\glref{UI}.

Also created using the~brainstorming method, the~task list is defined. Is is based on the~use cases created earlier. A~task is a~procedure that a~user has to do with the~application when achieving a~single goal. After defining the~tasks they are also analyzed.

After the~analysis is completed, a~prototype can be created. Prototypes are the~early drafts of the~\glref{GUI}, they serve as something to work on, a~physical representation of the~current \glref{GUI} design direction.  They are usually done with a~paper and pencil or a~professional prototyping software, but they lack functionality. Prototypes in this phase can also be called mock-ups, wire-frames or lo-fi prototypes.

The prototype is then evaluated using several evaluation processes. A~cognitive walk through, a~collaborative critiquing and a~heuristic evaluation should be done.  The cognitive walk through is an~attempt of an~expert to act as a user and walk through the~application. The collaborative critiquing is a~session where a group of people tries to find problems. And the~heuristic evaluation is about fulfilling the~heuristic rules and should be taken into consideration during the~whole design process.

\seccc Hi-fi phase

The hi-fi phase assumes the~completion of the~lo-fi phase and takes the~prototype further into reality. The hi-fi prototype adds functionality. It is an~illusion of the~final visual and interaction design. It also already runs on the~target platform and follows it's look\&feel. While it should mostly work like the~final application, the~actual application logic does not have to be implemented yet. Also, only the~main parts of the~application \glref{UI} are prototyped.

Also in the~hi-fi phase, an~iterative evaluation process is present. The prototype is implemented, tested, evaluated and then optionally redesigned over and over again. Usually the~final design is used in the~application itself, which, however, does not have to be the~best way.

The evaluation in this phase is already done with users, but also testing without users is present to check the~direction correctness (heuristic testing etc.). Usability testing is performed and depends on the~application itself. As mentioned in~\cite[Nielsen2012], five users should be enough to test an~application, as an~additional tester does not add as much precision.

%	------------------------------------------------------------------------Business requirements ----------------------------------------------------------------------%
\label[analysis.requirements]
\sec Business requirements

Business requirements describe the~application from the~business view. They do not describe exact details, neither they describe easily measurable requirements. It is a~set of  {\it what} should be achieved with the~developed software. Simple business requirements follow:

\begitems
* Minimizing the~cognitive load,
* simple and consistent user interface,
* fast and responsive,
* usability before attractivity,
* performance before delightful details,
* rich, extensible functionality:
\begitems
  * display information about car,
  * display common information (time, battery, weather, ...),
  * etc.
\enditems
\enditems


%	------------------------------------------------------------------------ Use cases ----------------------------------------------------------------------%
\label[analysis.use_cases]
\sec Use-cases

Use-cases describe objectives users want to achieve with a~system. They describe not only the~\glref{UI}, but also the~functionality. They are usually named with a~verb and optionally a~noun. The name should be descriptive enough in order to give a~proper idea about the~specific goal.

The use-case list is based on the~analysis so far. It is inspired by the~research on existing applications in section \ref[analysis.existing_applications] and the~general idea of the~application mentioned in section \ref[introduction.motivation].

\begitems
* Display information from the~car,
* display device information (time, battery, etc.),
* display icons for the~information to be easily recognizable,
* allow customization of displayed information,
* provide safe controls,
* provide easy access to other applications,
* support different themes (light, dark).
\enditems

\label[analysis.gui.task_list]
\sec Task list

The tasks are based on the~use-cases, they are more exact subtasks of the~use-case scenarios. A~single use-case scenario can be done by performing one or multiple tasks from the~task list. They describe the~system from the~user perspective.

\begitems
* Display a~single piece of information,
* add a~display:
\begitems
  * select a~position for a~new display,
  * select a~desired information or
  * select a~desired action:
\begitems
    * select a~simple action or
    * select an~external application,
\enditems
\enditems
* remove a~display,
* invoke an~external application:
\begitems
  * add external application display,
  * invoke an~external application on touch,
\enditems
* change a~theme,
* create a~group of displays,
* move to another group of displays,
* move back from another group of displays,
* go back.
\enditems

%	------------------------------------------------------------------------ Server ----------------------------------------------------------------------%
%\sec Server
%
%
%\secc Functionality
%
%
%\secc Data storage
%
%
%\secc Communication
%
%
%	------------------------------------------------------------------------ Development and support tools ----------------------------------------------------------------------%
\label[analysis.development_and_support_tools]
\sec Development and support tools

A~fluent development process cannot be done without proper development and support tools. These tools provide additional safety of code (prevention from loss of code), additional protection layer against bugs (automatic tests), help with implementation (code-completion, linking etc.) and more.

\label[analysis.development_and_support_tools.ide]
\secc Development environment

Even though using text editor and command line is an~option, for speed of development only Integrated Development Environments are considered. In the~time of writing this text, there were two possibilities for Android development -- Eclipse and Android Studio.

\seccc Eclipse

Based on research by Oliver White~\cite[White2014], the~Eclipse \glref{IDE}\fnote{\url{https://eclipse.org/}} is the~most often used Java \glref{IDE}. That is probably the~reason why Google Inc. suggested this \glref{IDE} for Android development in early phase. However, Eclipse has lost Android development support in late 2014~\cite[Duckett2014].

\seccc Android Studio

Released in 2014, Android Studio\fnote{available at \url{http://developer.android.com/tools/studio/index.html}} became the~main platform for Android development. It is based on IntelliJ IDEA \glref{IDE} and supported by Google Inc. For that reason, it is an~obvious choice for new applications to be developed in Android Studio.


\label[analysis.development_and_support_tools.vcs]
\secc Version control system

Versioning is very important part of a~software development process. Being able to go back to working version or to develop new features while the~main version is still working, is priceless. Currently there are three main \glref{VCS} worth considering (based on an~article\fnote{\url{http://www.sitepoint.com/version-control-software-2014-what-options/}}). 

\seccc Subversion

Subversion\fnote{\url{https://subversion.apache.org/}} has a~single repository where all the~data are stored. This simplifies the~backup of a~whole project, because all the~data are located in one place. This, however, creates possible threat of data loss when the~central repository gets corrupted without backup.

Because of the~central repository, Subversion allows read and write access controls for every single location and have them enforced across the~entire project, which can come in handy when developing in a~large community, but it is usually not required when developing in a~small team.


\seccc Mercurial

Mercurial\fnote{\url{https://www.mercurial-scm.org/}} is a~distributed source control management tool, it focuses on performance and scalability. It also gives a~high priority to keeping history as it is fairly difficult to alter historic data inputs. Also several \glref{GUI} tools exist for the~Mercurial version control system.

\seccc Git

Git\fnote{\url{https://git-scm.com/}} is a~widely used version control system. It uses a~concept of distributed repositories. Those repositories contain immutable objects identified by the~hash of their content. This makes the~history very safe, as there is no way of changing a~commit. However a~commit can be replaced with another commit and the~development story can be altered, making it well-arranged for the~potential needs of future analysis. It also supports branching and staging.

\seccc Conclusion

As the~author has a long experience with Git and it is also one of the~most widely used \glref{VCS}, it will be used for version controlling. It is continuously being improved and enhanced, it supports various additional functionality (for example by using hooks) and is overall widely supported, therefore Git seems to be the best choice.

\label[analysis.development_and_support_tools.tdd]
\secc Test driven development

Being one of the~main development approaches in the~last decade, test driven development helps to develop an~application quickly and fluently. The main idea of \glref{TDD} is to create automatic tests before the~actual application code. While this enforces a~developer to think twice when creating tests, which makes him think about what he actually wants to achieve, it also helps against random errors in code. Having the~application tested with every build also supports continuous integration, which is described later in this text.

The most usual tool in Java is the~JUnit framework\fnote{\url{http://junit.org/}}. It allows writing simple repeatable tests and is an~instance of the~xUnit architecture. Also \glref{API} for testing from the~Android support libraries will be used, as the~application environment is specific and for proper testing, an~access to certain resources and objects is necessary.

\label[analysis.development_and_support_tools.ci]
\secc Continuous integration

{\it ``Continuous Integration is a~software development practice where members of a~team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day. Each integration is verified by an~automated build (including test) to detect integration errors as quickly as possible.''}~\cite[Fowler2006]

Continuous integration supports rapid application development while giving the~much needed feedback, so that a~developer can see and adjust the~direction, which the~application development takes. 

For simple \glref{CI} integration in practice, there are several online services. For this particular application development, Travis\fnote{available at \url{https://travis-ci.org/}} system was chosen. While offering usual \glref{CI} functionality, it also integrates easily with GitHub\fnote{\url{https://github.com/}} and Gradle\fnote{\url{http://gradle.org/}} build system. 

\label[analysis.development_and_support_tools.eval]
\secc Test evaluation

As described in a section about usability testing (\ref[testing.users]), testing with users on a~car simulator will be performed. There is an~eye-tracking system on the~simulator as well, therefore there will be huge amount of data gathered from both the~simulator and the~eye-tracker. A~proper software must be used to analyze these data and to present them. Also it has to be purchasable cheaply or for free. A~few options will be described here: Wolfram Mathematica, Matlab and R.

\seccc Wolfram Mathematica

Wolfram Mathematica\fnote{\url{https://www.wolfram.com/mathematica/}} is a~professional software for technical computing. It covers all areas of technical computing from mathematics, physics and so on. It is based on Wolfram Language, which has strong algorithmic power as well as wide range of capabilities. In Wolfram Mathematica pretty much every technical computation can be done in the~most reasonable time. It has one of the~most advanced help systems available with hundreds of thousands examples.

However, all of this does not come for free. The Wolfram Mathematica software is very costly and for purpose of this thesis, a~minimum functionality would be used. As the~results of the~testing will probably be presented later in a~research paper, a~professional license would have to be used.

\seccc Matlab

Matlab\fnote{\url{http://www.mathworks.com/products/matlab/}} is another software known for it's technical computing capabilities. It is capable of numeric computation, data analysis and visualisation, programming and algorithm development and even application development and deployment. It is a~high-level language and an~interactive environment on it's own.

The disadvantage is the~price of Matlab. Even a~student license is very costly and a~professional license would be needed in the~future for the~research paper release. It might be an~option in the~future, however it is not a~viable option now.

\seccc R

R\fnote{\url{https://www.r-project.org/}} is a~free software environment focused on statistical computing. It does not have as wide area of use as the~software mentioned above, but it is still capable of analyzing large sets of data, which means it might just be enough for the~test results to be analyzed properly. Should it not be enough, a~different approach has to be taken.

Even though it is completely free, the~use and functionality it not limited. Also it fits the~cheep purchase requirement making it a~viable choice. Therefore, R will be used for test results analysis and evaluation.

%	------------------------------------------------------------------------ On-Board Diagnostics ----------------------------------------------------------------------%
\label[analysis.obd]
\sec On-Board Diagnostics

On-Board Diagnostics stands for a~self-diagnostic equipment requirements for automotive vehicles. The modern implementations offer standardized communication port to provide real-time data as well as diagnostic trouble codes.

Currently there are two versions of \glref{OBD}. The first one (\glref{OBD} I) provides only diagnostic trouble codes. The second one (\glref{OBD} II) adds real-time vehicle data. The third version (\glref{OBD} III) is currently being developed. It should support so called ``remote \glref{OBD}'', which would broadcast the~data to other vehicles, which could prevent collisions by warning the~drivers when something bad happens.~\cite[Obd] 

\label[analysis.obd.connection]
\secc Connection

To connect to the~\glref{OBD} II, an~\glref{OBD}-II Blue-tooth Adapter (often also referred to as Dongle)  has to be connected to the~car. This dongle then enables creating a~bluetooth connection and via that connection it provides a~communication channel. Some dongles also support Wi-Fi.

\label[analysis.obd.api]
\secc API

The \glref{OBD} communication protocol supports certain modes and allows reading information on certain PIDs. The mode is used to set a~mode of an~\glref{OBD} adapter. As stated in the~latest \glref{OBD}-II standard SAE J1979\fnote{\url{http://standards.sae.org/j1979_201408/}} there are 10 modes available. Based on the~current mode the~adapter behaves differently. The modes are:
\begitems
* Show current data,
* show freeze frame data,
* show stored Diagnostic Trouble Codes,
* clear Diagnostic Trouble Codes and stored values,
* test results, oxygen sensor monitoring,
* test results, other component/system monitoring,
* show pending Diagnostic Trouble Codes,
* control operation of on-board component/system,
* request vehicle information,
* permanent Diagnostic Trouble Codes.
\enditems

Vehicle manufacturers are not required to implement all the~modes as well as they are not required to implement all the~PIDs. However, there is a~special request available to receive the~list of supported PIDs. This is done via sequence of bits stating 1 for supported and 0 for not supported PIDs.

For every mode, there are different PIDs available. The actual vehicle data (such as speed, fuel, engine load, temperatures, etc.) are available via modes 1 and 2. The Diagnostic Trouble Codes are available via modes 3, 7 and 9. For information retrieval, a~hexadecimal number is sent to the~adapter containing the~PID number according to the~data requested. The full table of PID codes is available at the~\glref{OBD}-II wikipedia page\fnote{\url{https://en.wikipedia.org/wiki/OBD-II_PIDs}}.

As the~\glref{OBD} is widely used in software, libraries used for accessing the~data are available. Such library can save a~lot of work required to implement the~communication protocol, to solve all the~safety issues as well as to cover different vehicles. For such task, an~\glref{OBD}-II Java \glref{API} library\fnote{available from \url{https://github.com/pires/obd-java-api}} will be used~\cite[Pires].

\label[analysis.obd.data]
\secc Data


The \glref{OBD}-II covers nearly all the~driving data one can imagine a~vehicle knows. It goes from the~usual data, such as vehicle speed or engine RPM, to less usual such as multiple oxygen sensors. As mentioned earlier, the~full table of the~data provided is available at the~\glref{OBD}-II wikipedia page. All of these data should be available (via the~application) to the~driver if he demands it and if the~car supports it 


%------------------------------------------------------------------------ DESIGN ------------------------------------------------------------------------%
\label[design]
\chap Design 

This chapter is about the~design process. The first section is about the~application architecture, it's requirements and the~platform conditions. It is followed by a~thorough description of the~\glref{GUI} design process divided into four phases as parts of the~iterative process. 

%	------------------------------------------------------------------------ Application architecture ----------------------------------------------------------------------%
\label[design.application_architecture]
\sec Application architecture

Designing a proper application architecture is one of the~main and most challenging tasks in the development process. Changing the~architecture in the future proves to be one of the~most expensive changes as for man-hours~\cite[McConnell2004]. Application architecture influences a data flow, a communication between components and overall application performance, as well as an extensibility and a possibility to change or add features in the~future. While the Android application architecture enforces certain components and platform features to be used, there is still a space for diversity.

\label[design.application_architecture.platform_limitations]
\secc Platform limitations

As mentioned in Android platform analysis in section \ref[analysis.android_platform] on page \pgref[analysis.android_platform], the~typical Android application consists of multiple Activities, which communicate with each other using Intents. While this approach supports the~loosely coupled concept, it makes certain inter-cooperations rather difficult.  Sharing an~object between activities usually means serializing the~object or saving it to the~database, which leads to deserializing or loading from the database later. When striving for excellent performance, this can emerge into a~serious problem. As the~Android platform does not allow database IO operations on the~main presentation thread, it requires background thread with callbacks to the~main one and a screen revalidation when such callbacks occur. It is critical to avoid such delays as much as possible when comes to car environment where fast reactions are required.

\label[design.application_architecture.extensibility]
\secc Extensibility

With the~current rapid application development there is a~need to be able to adjust an application based on market requirements. While creating a~new application with every new feature is a~possibility, it is certainly better to be able to add new features to the~old application so that it actually never becomes old. Extensibility is one of the~main requirements for many reasons. When it comes to the~application developed in this thesis, new features are planned to be added based on a user feedback. Therefore the~architecture must be prepared to be easily extensible.

The main approach to achieve a proper extensibility should be to write a~clean code, which can prove to be a~good idea when considering nearly every part of an implementation process. Also the~modularity concept is very useful when it comes to extensibility and it will be discussed in section \ref[design.application_architecture.modularity].

\label[design.application_architecture.modularity]
\secc Modularity

\seccc Note for Android platform limitations

The first considered approach was to create requirements on modules, such as manifest file as a~descriptor and an~implementation file with source codes and resources, so that the~modules could be loaded dynamically and the~extensions could be customizable. Then a~user-base could develop modules on their own and add them freely into the~application once they meet the~requirements.

However, the~Android concept with XML layouts does not allow their inflating during runtime. Because it is a~performance-expensive operation, it pre-processes a~XML file when building the~application, as quoted below.

{\it``For performance reasons, view inflation relies heavily on pre-processing of XML files that is done at build time. Therefore, it is not currently possible to use LayoutInflater with an~XmlPullParser over a~plain XML file at runtime.''}~\fnote{from documentation available at \url{http://developer.android.com/reference/android/view/LayoutInflater.html}}

\seccc Overview 

Modularity concept allows application to contain certain modules, each offering a~certain functionality based on some predefined requirements. The modularity will be supported via extending predefined classes and implementing required functionality (such as action on update). This limits the~modularity, however it is not suitable to do it differently at the~moment given the~restrains mentioned above.

\label[design.application_architecture.adaptability]
\secc Adaptability

Because the~space on the~screen is limited and also unknown in advance (multiple devices have varying screen sizes) and every user might want to see a~different kind of information, he must be able to modify the~layout, to choose the~information he wants to see. The application must be adaptable to user's needs and requirements, so that he can control the~application fluently and spend as little time as possible seeking the~requested information.

For that reason there will be module containers which can contain multiple modules. A user then selects the~module for each container and selects a~single container to be displayed at a~time. This allows to build custom module sets for greater adaptability.

\label[design.application_architecture.architecture]
\secc Architecture

A~multilayer architecture will be used for the~application. With the~Android architecture requirements, a~modified \glref{MVC} architecture will be used, where an~Activity works as a~controller and partially as a~view. The activity will contain a set of modules, which are single-purpose elements based on the~predefined classes (as mentioned in section \ref[design.application_architecture.modularity]). Those modules will communicate via interface, which will be implemented by the~activity. Also an~event-driven approach will be used in communication, especially with timed events. 

\par\maybebreak 3.5cm
%	------------------------------------------------------------------------ GUI ----------------------------------------------------------------------%
\label[design.gui]
\sec GUI

Given the~car environment, designing a proper graphical user interface is crucial for an~in-car application. Not only it has to look good, it also has to consider safety issues such as minimizing the~cognitive load and required glance time to control the~application or to read displayed information. To achieve that the~\glref{GUI} should follow the~principles mentioned in section \ref[analysis.gui].

\label[design.gui.phase_one]
\secc Phase one

In the~early phase of the~design process, the~main idea was to display a~single piece of information at a~time. Given that, a~certain concept was created with a~single application panel per screen, which would be a~scrollable list. Swiping left or right would change the~focus to another application panel. Part of the~previous and following application panel would be seen as shown in figure \ref[design.gui.draft1].

\medskip
\centerline{
\clabel[design.gui.draft1]{GUI draft \#1}
\inspic images/design_gui_draft1.png
}
\nobreak\medskip
\caption/f GUI draft \#1 with multiple panels
\medskip

This concept was recreated into a~similar concept with a difference in sizes of a previous and a following application panel. Those panels would be moved into the~background which would make them smaller, as shown in figure \ref[design.gui.draft2], however, more of these panels could be visible letting the~user know more about the~actual structure. Also, it presents combination of a~name and an~icon for easier recognizability.

\medskip
\centerline{
\clabel[design.gui.draft2]{GUI draft \#2}
\inspic images/design_gui_draft2.png
}
\nobreak\medskip
\caption/f GUI draft \#2 with the~next and previous panels pushed into the~background
\medskip

For both drafts the~following applies. The swipe action would invoke text-to-speech action telling user the~name of a~selected panel. This could lower the~need to look at the~application screen while driving. Also, all the~panels would have different colors making them recognizable on the first sight. The touch on an~application panel would invoke the~related application. This could be a~music player, a~map, etc. Examples of a~music player sub-application are shown in figures \ref[app.design.gui.draft3] and \ref[app.design.gui.draft4] in the~appendix B on page \pgref[app.design.gui.draft3].

\seccc Advantages

\begitems
* {\bf Readability} -- given a~single panel per screen with only a~name and an icon in it, the~font can be large enough to be properly readable.
* {\bf Colors} -- colors can distinguish separate applications panels making them easily recognizable once the~user learns the~colors for each application.
\enditems

\seccc Disadvantages

\begitems
* {\bf Consistence} -- however is the~main screen consistent, the~invoked sub-applications are not. The concept does not force them to be, neither it gives a~clue about how they should look.
* {\bf Limited} -- the~main screen has a~limited functionality (near to none) while the~layout of sub-applications would have to be created independently every time a~new feature is implemented. This also limits easy extensibility as creating a~proper \glref{GUI} is not a~simple task with the~given constraints.
\enditems

\label[design.gui.phase_two]
\secc Phase two

The next step was to fix the~problems mentioned above. Being inspired by the~reviewed applications (\ref[analysis.existing_applications]) one attempt ended with the concept shown in figure \ref[design.gui.draft5]. It presents a~vertical list of applications displayed in a~column on the~right side of the~screen instead of a~horizontal list over the~whole screen. The main area contains the~usual car data such as speed, rpm and consumption.


\medskip
\centerline{
\clabel[design.gui.draft5]{GUI draft \#3}
\inspic images/design_gui_draft5.png
}
\nobreak\medskip
\caption/f GUI draft \#3 with the~main section in the~center and the~menu in the~right panel
\medskip


The second image \ref[design.gui.draft6] shows possibility of inserting a~sub-application screen between an~application list and car data, for example a~navigation. Also, it presents the~concept of micro-controls in an~application list. It would allow a~single control button to be displayed on an~application panel such as pausing a~song or muting the~music player. 

\medskip
\centerline{
\clabel[design.gui.draft6]{GUI draft\#4}
\inspic images/design_gui_draft6.png
}
\nobreak\medskip
\caption/f GUI draft\#4 with additional application screen in the~center, pushing the~car data to the~left panel
\medskip


\seccc Advantages

\begitems
* {\bf Controls} -- the~concept shows improvement in consistent functionality for displayed application panels, which eases the~control.
\enditems

\seccc Disadvantages

\begitems
* {\bf Minimality} -- the~amount of data grows and it appears to be too much. There are different kinds of data displayed at the~same time.
* {\bf Consistency} -- the~vertical application list is consistent, however, the~central panel is still suffering from the lack of consistency, as every sub-application can have a~different layout.
\enditems

\label[design.gui.phase_three]
\secc Phase three

The next step towards a consistency and a space usage was to create a~grid. This grid would be adjustable based on a~screen size, displaying the~proper amount of application panels for a~given device. As shown in figure \ref[design.gui.draft7], it is just an~extension of a~previously shown vertical list making it vertical and horizontal -- two dimensional.

\medskip
\centerline{
\clabel[design.gui.draft7]{GUI draft\#5}
\inspic images/design_gui_draft7.png
}
\nobreak\medskip
\caption/f GUI draft\#5 with a~grid of panels
\medskip


Adding functionality to this grid, a~new card concept emerged. It consists of cards, which provide additional information as well as control elements (as shown in figure \ref[design.gui.draft8]). They would be active demo-versions of the~full applications, which would then be invoked by a touch to the~upper area of the~card, as shown in figure \ref[app.design.gui.draft9] in the~appendix B.


\medskip
\centerline{
\clabel[design.gui.draft8]{GUI draft\#6}
\inspic images/design_gui_draft8.png
}
\nobreak\medskip
\caption/f GUI draft\#6 with a~grid of panels, which display information and offer basic functionality
\medskip


\seccc Advantages

\begitems
* {\bf Accessible functionality} -- the~concept shows basic functionality available without a~need of invoking the full application. This allows a~user to remain in the~main screen in most cases.
\enditems

\seccc Disadvantages

\begitems
* {\bf Controls} -- in order to fit in the~card area, the~controls might prove to be too small, which makes it difficult to touch them
* {\bf Readability} -- in order to fit in the~card area, the~text might have to be too small, which makes it difficult to be read 
\enditems

\par\maybebreak 3.5cm
\label[design.gui.the_final_design]
\secc The final design

\medskip
\centerline{
\clabel[design.gui.draft10]{GUI draft\#7}
\inspic images/design_gui_draft10.png
}
\nobreak\medskip
\caption/f GUI draft\#7 with a~grid of simple panels 
\medskip

Because every single one of the~previously mentioned designs had at least one critical disadvantage, a~new approach had to be taken. Because of consistence, every element must be specified. But considering the~need for simplicity, there must be very limited amount of these elements.

Given the~requirements for both consistence and simplicity as well as extensible functionality, the~elements are divided into two groups: these, that display information and these, that control the~application. The simplest way appeared to be the~following: one element serves as a~display element, which displays one and only one kind of information, and the~second element serves as a~control button, which allows user to perform a~single action. Every kind of functionality appears to be achievable by these elements or by sets of these elements.

Also, for improved adaptability a~hierarchy model was considered, which makes it possible to create independent sets of functionality using a~hierarchical model, which supports the~consistence and simplicity by repeating the~same pattern in distinct areas.

As shown in figure \ref[design.gui.draft12], the~display panel consists of a~name, an~icon, a~value and a~unit. The control button is more simple, it consists of a~name and an~icon. An icon serves as a~checkpoint for eyes to seek out the~requested information quickly.

\medskip
\centerline{
\clabel[design.gui.draft12]{GUI draft\#8}
\inspic images/design_gui_draft12.png
}
\nobreak\medskip
\caption/f GUI draft\#8 presenting the~action panel (left) and the~display panel (right)
\medskip

The idea is to have several screens containing several application panels (where amount of panels is based on screen size) with changing the~screen by swiping left or right. As mentioned in section \ref[analysis.android_platform.material_design] on page \pgref[analysis.android_platform.material_design], Android suggests using vertically scrollable lists when presenting large sets of data. This can be suitable in most cases, however, in a~car a~user can easily swipe too heavily and scroll elsewhere and getting back to original place can put an~unnecessary load on the~driver's attention. Therefore there have to be separate pages, where one swipe changes a~page by one.

As for the~colors, a~proper contrast has to be present for a~good readability. As mentioned in section \ref[analysis.gui.ui_in_a_car_environment] on page \pgref[analysis.gui.ui_in_a_car_environment], two modes should be present. While light mode offers good readability even in a~direct sunlight, it blinds the~driver during the~night time as it emits too much light. Therefore it is a~good idea to implement a~dark mode as well for a~night time usage. For the~highest contrast possible, white on black or black on white are the~best options. 

\seccc Advantages

\begitems
* {\bf Minimality} -- only a~single value is displayed per each panel,
* {\bf familiarity} -- using familiar (platform specific) icons should ease the~information seeking process,
* {\bf consistence} -- consistent hierarchical model with only two types of elements,
* {\bf integration} -- using platform specific icons and specifics is a~part of realization process,
* {\bf simplicity} -- again, there are only two kinds of elements, which is simple enough,
* {\bf readability} -- because of the~good contrast the~text will be easily recognizable and readable.
\enditems

%------------------------------------------------------------------------ REALIZATION ------------------------------------------------------------------------%
\label[realization]
\chap Implementation

This chapter is about the~whole realization process -- a~process of implementing the~application with it's logic and \glref{GUI}. It starts with a~section about preparation, which provides an~insight into the~preparation of implementation environment and tools. It is then followed by a~description of a tablet specific part and then the~actual core of the~application. At last the~final \glref{GUI} is described.

%	------------------------------------------------------------------------ Preparation ----------------------------------------------------------------------%
\label[realization.preparation]
\sec Preparation

While this thesis focuses on creating a~tablet application, it's functionality could be shared amongst other Android platforms just by reflecting the~differences. A~possibility to extend application to a~mobile or any other platform creates a~need to divide a~single project into two -- a~core with a shared functionality and a~tablet part which focuses on the tablet \glref{GUI} and other specifics.

\label[realization.preparation.environment]
\secc Environment

As mentioned in analysis section \ref[analysis.development_and_support_tools.ide] on page \pgref[analysis.development_and_support_tools.ide], Android Studio \glref{IDE} is used for the code development. As it does not allow importing other project as a~library, it requires a~shared project to be registered as a~module. This module has to be placed in a~project sub-folder and it is an~Android Studio project of it's own. This is done by adding a~new module and selecting a~library module.


\label[realization.preparation.versioning]
\secc Versioning

Because of the~workaround with a~shared library in Android Studio, a~special approach has to be taken. As Git supports submodules, a~shared library has to be registered as one. This can be achieved by calling a command ``{\tt git submodule add LIBRARY\_REPOSITORY\_URL}'' in the~root project folder and then adding the~library sub-folder into the~``{\tt .gitignore}'' file.

%	------------------------------------------------------------------------ Tablet ----------------------------------------------------------------------%
\label[realization.tablet]
\sec Tablet specific

While the~Android \glref{API} is shared across all Android platforms, it is the~device size that is usually different. The \glref{GUI} has to adapt based on a~platform and therefore it's implementation differs. This section describes the~tablet-related implementation using a~shared library described in section \ref[realization.core].

\label[realization.tablet.activity]
\secc ModulePagerActivity

As mentioned in analysis section \ref[analysis.android_platform.architecture] on page \pgref[analysis.android_platform.architecture], an~Activity is a~basic component of every Android application. In this case, it is the~only launch point of the~application, it implements so called {\tt IModuleContext} interface described in section \ref[realization.core] on page \pgref[realization.core], which controls the~interaction with modules (\ref[design.application_architecture.modularity]). Presentation of a screen content is delegated to {\tt ModulePageFragment} (\ref[realization.tablet.fragment]).

While usually multiple activities are present in a~single application, thanks to consistent hierarchical model a~single activity class can be reused for multiple instances with different data, which means that there is a~single activity invoked per one requested set of modules.

\seccc Improvements

There are some improvements implemented for performance, battery consumption and hardware overloading prevention reasons, one of which is reacting to an Activity state by disabling inactive modules. Because of the~independent module concept, modules display data on their own and they do not know when the~data are requested. Therefore, the~activity uses a~list  of these modules (as listeners) to deactivate them when entering a~paused or stopped state. % should be done through event bus?

Also, sometimes it is required to restart the~entire application, for example when some global changes need to be performed. As the~Android architecture saves latest activities in a~stack as mentioned in section \ref[analysis.android_platform.architecture] on page \pgref[analysis.android_platform.architecture], it is necessary to clear this stack first, so that the~OS does not backtrack to an~old Activity. This is done by keeping control over existing activities and ending them one by one. This can also be used when forcing the~application to exit, as there is no proper option to end an~application on Android platform from the~application developer's view. 

\label[realization.tablet.fragment]
\secc ModulePageFragment

As mentioned in section \ref[analysis.android_platform.architecture] on page \pgref[analysis.android_platform.architecture] a~Fragment can take over part of an Activity's functionality. In this case a~{\tt ModulePageFragment} handles the~presentation of a module set using a~{\tt ModuleFragmentAdapter} (\ref[realization.tablet.adapter]) for obtaining the~data and a~custom layout {\tt GridLayout} (\ref[realization.tablet.gridlayout]) for displaying them in a~grid.


\label[realization.tablet.adapter]
\secc ModuleFragmentAdapter

{\tt ModuleFragmentAdapter} follows the~adapter concept, where an extension of the Android \glref{API} class {\tt Adapter} is used to cover the~access to a list of data. This adapter gets a~single {\tt ParentModule} (described in section \ref[realization.core.modules] on page \pgref[realization.core.modules]) and retrieves it's submodules on demand.

\label[realization.tablet.gridlayout]
\secc GridLayout

Because the~Android concept does not expect the functionality required by this application, a~library class {\tt android.widget.GridLayout}\fnote{more information available at \url{http://developer.android.com/reference/android/widget/GridLayout.html}} is not suitable for this situation. As mentioned in section \ref[design.gui.the_final_design] on page \pgref[design.gui.the_final_design], Android suggests the~lists to be scrollable vertically. This is a~functionality fully supported by {\tt android.widget.GridLayout} but unsuitable for the~given use-case.

For reasons mentioned above a~custom layout had to be created. Based on given measurements (of a~module tile, a~space) it computes amount of modules displayed per page and also their positions. Given the~computed positions it then lays out all the~provided modules.


%	------------------------------------------------------------------------ Core ----------------------------------------------------------------------%
\label[realization.core]
\sec Core

The core contains all the~functionality, it handles data, logic and also a~standardized part of presentation, which consists of predefined single module views. Everything will be described in the~following text.
                        
\label[realization.core.modules]
\secc Modules

As mentioned in section \ref[design.application_architecture.modularity], there are so called modules, which handle the~interaction between the~application and it's user offering a~single action or information. Together they can create multiple connected sets of functionality with consistent interface.

\label[realization.core.modules.imodule]
\seccc IModule

{\tt IModule} is an~interface which covers the~basic module functionality. It has to be implemented by every single module in order to achieve a proper polymorphism. Using this approach, a~tablet implementation can display a~set of modules without knowing which module does what.

\label[realization.core.modules.abstractsimplemodule]
\seccc  AbstractSimpleModule

{\tt AbstractSimpleModule} is an~abstract class which implements most of the~{\tt IModule}'s functionality. It handles creating a~unique Id for every module, which will be described later in section \ref[realization.core.data]. It also handles common module events and overrides simple methods to ease the~implementation of a~new module, which does not need these methods. Every other module extends this class.

\label[realization.core.modules.abstractparentmodule]
\seccc AbstractParentModule

For consistent hierarchical model, there has to be a~module containing other modules. This module extends the~{\tt AbstractParentModule} class, which covers a~mo\-du\-le container functionality. Every instance of a~{\tt ModulePagerActivity} (\ref[realization.tablet.activity]) contains such container and displays it's content as a~list of modules.

\label[realization.core.modules.abstractdisplaymodule]
\seccc AbstractDisplayModule

Displaying information is one of the~most important goals of the~CarDashboard application. {\tt AbstractDisplayModule} is the~base class to be extended by modules displaying information. It handles updating a~displayed value on request. It also supports text-to-speech, as the~value is said out-loud on touch.

\label[realization.core.modules.abstracttimedupdatedisplaymodule]
\seccc AbstractTimedUpdateDisplayModule

{\tt AbstractTimedUpdateDisplayModule} serves as an~extension to the~{\tt AbstractDisplayModule} handling automatic timed updates. It uses advanced generics to offer multiple update modes for extending modules. Such mode states the~frequency of calling the~{\tt getUpdatedValue} method, which is to be implemented by subclasses. An optimization is implemented for this process, as {\tt getUpdatedValue} can invoke a~long-lasting process. The last value is saved for further use by the~{\tt updateValue} method, while the~{\tt getUpdateValue} method merely updates this last value when it is done.

\label[realization.core.modules.abstractshortcutmodule]
\seccc AbstractShortcutModule

As mentioned in section \ref[analysis.android_platform.architecture], there is an~Intent as a~mean of communication. This Intent is able to invoke an~Activity, a~Service and many other things. It can also invoke an~Activity of a~different application installed on the~device, which launches the~application. The {\tt AbstractShortcutModule} handles invoking a~custom Intent.

%As an~extension to application functionality there is an~option to invoke external applications as well. The {\tt AbstractShortcutModule} has a~functionality of a~shortcut to such external application. The developed application can then act as an~application launcher optimized for in-car usage.

\seccc Other modules

There are several implementations of the~modules mentioned above. A~few will be shortly described in the~following list:

\begitems
  * {\bf SimpleShortcutModule} -- a~mere implementation of the~{\tt AbstractShortcutModule} class (\ref[realization.core.modules]),
  * {\bf SimpleParentModule} -- a~mere implementation of the~{\tt AbstractParentModule} class  (\ref[realization.core.modules]),
  * {\bf AppShortcutModule} -- an~extension to the~{\tt AbstractShortcutModule} which limits to Intents invoking other installed application, therefore the~CarDashboard can serve as an~application launcher optimized for in-car usage,
  * {\bf EmtpyModule} -- also referred to as an add module, it is meant to be swapped for a~different one, occupying an~empty space,
  * {\bf BackModule} -- a~module handling a~back button, which can be pressed to get back to the upper parent module (go up in the~hierarchy),
  * {\bf LightButtonModule} -- a~module created for IoT support, offering a~way to turn a~given light on or off,
  * {\bf ObdRpmModule} -- a~module communicating with the~\glref{OBD} and displaying information about current RPM of the~vehicle,
  * {\bf ObdSpeedModule} -- a~module communicating with the~\glref{OBD} and displaying information about current speed of the~vehicle.
\enditems 

\label[realization.core.modules.imodulecontext]
\seccc IModuleContext

An interface to be implemented by an~Activity which should display the~modules. It provides functionality to go up or down in a module hierarchy, to toggle a quick menu for a~certain module or to gain access to resources.

\seccc Quick menu

A~quick menu serves as a~quick options menu for a~simple module. Every module can invoke such quick menu. Usually it contains {\it cancel}, {\it edit} and {\it delete} options. It might contain other options specified by the~given module.                                                                           

\label[realization.core.application]
\secc Application

This section describes the~application logic. While most of the~logic is hidden in modules themselves, the~communication across application components must be handled elsewhere.

\seccc UpdateApplication

{\tt android.app.Application} is the~main class of the~Android architecture. There is a~single instance of this class per application. For that reason, this class is extended and enhanced with creating and starting timers for timed updates. An instance of this extended class is to be used by the~tablet implementation instead of the~original {\tt android.app.Application}.

\seccc FastEventBus

The concept of event bus is to have publishers and subscribers. It is most suitable for timed events, which serve as a~signal for modules to update themselves. However, it is not limited just for the~time updates. Most of the~communication can be handled using the~event bus. The~{\tt FastEventBus} offers such functionality while still being as simple as possible for better performance.

\label[realization.core.data]
\secc Data

\seccc Resources

As mentioned in the section \ref[analysis.android_platform.architecture], resources usually consist of XML files accessible as static properties of the~automatically generated class {\tt R}. A~new class was created in this project to wrap the~access to resources for selected types of data. {\tt StringResource} and {\tt IconResource} classes wrap the~access to single sources of a resource, meaning that for example a~{\tt StringResource} can load the~string from a~resource or from a~runtime memory. Accessing a~resource this way separates the~resource user from the~data access layer, making the~code simpler.

\seccc Storage

As the~application is adjustable by users, the~settings need to be preserved. The main data area to be saved is the~user-customized hierarchy of modules. Given the~hierarchy model of these data and the~simplicity of content (module type, name, additional data), a~\glref{JSON} format is used for the data persistence. A~single \glref{JSON} file is created containing all the~required data for a~customized user interface. The advantage of the~\glref{JSON} format is the~ability to easily persist these settings on a~server given the~support of \glref{JSON} format from web communication protocols.

To save and load these data there is a~class {\tt ModuleDAO}. This class separates the~access code from the~rest of the~application, making it easy to change the~saving format, the~type of data saved or even the~location of data. It also enables data to be saved in a~background thread, so that the~saving process does not block the~application.

\seccc Runtime data

For performance reasons to avoid unnecessary loading and object creating, current modules are preserved in a~runtime data container called {\tt ModuleSupplier}. This container wraps the~access to modules based on their Id, as mentioned in section \ref[realization.core.modules] on page \pgref[realization.core.modules]. It also contains a~default set of modules when no preserved data are available.

Another advantage of this class is a~possibility to adapt. Should the~modules take too much space in memory, it is easy to switch to a~data loading model, where modules would be loaded into a~memory on demand and deleted when they are not currently in use. Doing such change would not affect the~rest of the~application.

\seccc Object creation tools

One of the~challenging tasks was to save and then load all types of modules. Since there can be custom modules, it is not an~easy task without requesting the~developer to create \glref{DAO} for every module. To simplify the~module implementation process as much as possible, a~set of creation tools was made. Once the~module fits in one of these tools, it can be loaded and created without further effort. However, once a~new module type is created, for example a~type which requires additional data to be saved, a~new tool has to be implemented into existing tools.

There are two types of these tools. The tools to create an~object based on a~loaded module data and the~tools to create an~object based on a~selected module when adding a~new one into the~structure. Both of these tools are based on Java reflection \glref{API}. For both of these tools a~map exists in the~{\tt ModuleCreationToolsMap} class based on the~module class. Every module class has to be registered with a~{\tt ModuleCreator} and a~{\tt ModuleLoader} before being able to be loaded or added.

The {\tt ModuleLoader} serves to create a~new object from previously persisted session. It is an~enum of many enum items, each of which implements a~method to load from a~{\tt JSONObject} and to save into the~{\tt JSONObject}. Support methods are provided for saving and loading common data, so that only the~specifics have to be implemented.

The {\tt ModuleCreator} serves to create a~new object when swapping the~{\tt EmptyModule} (\ref[realization.core.modules]). On the~first sight it is simpler than {\tt ModuleLoader}, because most modules can be created just by reflection (creating a~new module based on class with default data in it). However, several modules require custom data, such as {\tt SimpleShortcutModule}, {\tt AppShortcutModule}, {\tt GmapsShortcutModule}, etc. Those usually use custom Fragments handling the~user data input with callback methods back to the~creator. Those Fragments will be discussed later in the section \ref[realization.core.fragments] on page \pgref[realization.core.fragments].


\label[realization.core.fragments]
\secc Fragments

Following are {\tt DialogFragments}, which means Fragments in Dialog windows. The advantage of the~{\tt DialogFragment} is the~ability to adapt. On larger screens it is a~dialog window as a~pop-up, on smaller screen it is a~full-screen window.

\seccc ModuleListDialogFragment

This Fragment is used when adding a~new module into the~structure. It contains a~list of available modules in a~structure defined by the~developer. This structure uses description objects for all the~modules. When a~module is selected, based on it's class a~{\tt ModuleCreator} is obtained from the~{\tt ModuleCreationToolsMap} (\ref[realization.core.data]). Using this creator a~new module object is created and inserted into given position using a~callback method to {\tt IModuleContext} (\ref[realization.core.modules]).

\seccc ApplicationListDialogFragment

When a~shortcut to an~external application is selected as a~new module, an~{\tt ApplicationListDialogFragment} gets invoked by the~{\tt ModuleCreator}. Adapter of this Fragment loads all the~available applications installed on the~device and provides their data to the~{\tt ApplicationListDialogFragment}. The icons and names are displayed in a~list for a~user to select. Selecting a~module invokes a~callback method, which calls the~related method in the~{\tt ModuleCreator}.

\seccc CustomShortcutDialogFragment

When a~custom Intent is to be created as a~module, a~{\tt CustomShortcutDialogFragment} gets invoked. This Fragment offers input for a title and an Intent content and as usual, invokes a~callback method once the~data are provided.

\seccc GmapsShortcutDialogFragment

As an~extension to the previous, this Fragment allows creating custom Intents particularly for Google Maps. Using Google Maps \glref{API}\fnote{ \url{https://developers.google.com/maps/}}, it allows creating shortcut modules, which can invoke the~following:
\begitems
* Display a~location on a~map,
* launch navigation to a~certain location from the~current location,
* search the current location for a~given string, for example a hospital, a pharmacy or a gas station.
\enditems

\seccc RenameDialogFragment

{\tt RenameDialogFragment} has been added to allow a~user to change a~title of a~selected module. Because the~title is saved as a~{\tt StringResource} (\ref[realization.core.data]), it is source-independent on the~outside. Therefore, a~{\tt String} can be used instead of a~XML resource. The user can then customize his user interface a~bit more.

\label[realization.core.obd]
\secc OBD

While modules are as independent as possible, there are cases where a~shared functionality is required. Communicating with the~\glref{OBD} protocol is relatively expensive and it would be inefficient to handle it separately. Therefore the~communication is centered into a~single sub-package, which handles the~data retrieval using requests and saving the~responses for later use. Every module displaying the~\glref{OBD} data can then ask this package for an~information and receive it as quickly as possible.

Handling the~\glref{OBD} communication is done by a~background service which uses the~\glref{OBD}-II Java \glref{API} library~\cite[Pires] to send requests to the~\glref{OBD} and to receive results. It sends requests based on tasks from a~queue, where modules push their requests. This ensures that only currently needed information will be requested, minimizing the~load.

\label[realization.core.utility]
\secc Utility classes

There are several utility classes -- stateless classes providing certain sets of functionality. As a~utility class, every one of them is filled with static methods that help with frequently used operations that do not require to change the~outer state.

\seccc ModuleUtils

A~{\tt ModuleUtils} class implements several methods offering a~functional approach for lists of modules. Providing a~Single Abstract Method (\glref{SAM}) interface for an~action on an~{\tt IModule} given as a~parameter, it performs this action for each (even recursive) submodule of a~given parent module. Also a~particular module class or a~super-class can be provided, so that only the~related modules are affected.

The simpler method called {\tt forEach} merely iterates over all submodules, performs action on each one of them and if the~submodule happens to be also a~parent module, it calls itself recursively on this parent submodule as well.

The more complicated method called {\tt forEachDeepCopy} not only iterates recursively over all submodules, but also creates a~deep copy of all the~parent modules, so that changing their structure does not affect the~original. This is helpful when adjusting modules before saving them.

\seccc ModuleViewUtils

{\tt ModuleViewUtils} is a utility class providing methods to edit {\tt ModuleViews} described later in the section \ref[realization.core.view] on page \pgref[realization.core.view]. It enables filling them with a~data provided by a given {\tt IModule}, preparing listeners and quick menus. This covers the~access to certain View fields, separating the~view layer from the~rest.

\seccc ModuleViewFactory

A~{\tt ModuleViewFactory} class enables creating new {\tt ModuleViews} (\ref[realization.core.view]). It offers creation of a~simple {\tt ModuleView} or a~{\tt ModuleView} in a~certain holder {\tt View}. This holder can then wrap a~module and adjust it's size based on the~platform it is displayed on.

\seccc TextToSpeechUtils

This class provides simplified text-to-speech functionality. It handles all the~settings and preparations and a~calling object merely has to provide a~string to be read out-loud. This class is especially useful given the~environment and it is often used with several modules. For example, all the~implementations of {\tt AbstractDisplayModule} (\ref[realization.core.modules]) use the~text-to-speech functionality when touched, saying the~related value. Once the~driver memorizes the~position of a~module, he can easily push it without even looking at it and still receive the~information about value.

\label[realization.core.view]
\secc Views

As the~in-car \glref{GUI} is not the~usual type of \glref{GUI}, it requires several implementations of custom {\tt Views}. Some provide functionality that is not provided by the~Android \glref{API}, some minimize the~programming effort when working with modules as well as cover the~low-level implementation.

\seccc AutoResizeTextView

To be able to create custom modules easily, it is necessary to create automatically adjustable elements. Such element is the~{\tt AutoResizeTextView}, which automatically resizes the~text based on the~space provided. This enabled the~information to be as large as possible, while still being able to display several types of data (even longer strings). This class is used to help displaying an~{\tt AbstractDisplayModule} (\ref[realization.core.modules]).

\seccc ModuleView

{\tt ModuleView} is a~main element of a~presentation layer for a~module. It handles accessing the~inner data, such as a~title or an~icon, as well as access to the~related module object. The~{\tt ModuleView} is an~extension to the~{\tt android.widget.RelativeLayout} and uses a~XML descriptor, from which it is inflated.

\seccc ModuleActiveView

{\tt ModuleActiveView} is an~extension to the~{\tt ModuleView}, it uses a~different XML layout descriptor and adds a~value and unit data display. It is optimized for frequent data updates by saving the~pointer to the~{\tt View} containing the~actual value. This avoids the~unnecessary load when seeking an~element inside a~layout.

\seccc Other views

There are many other views similar to the~ones described above or just simple views used for displaying custom lists. Those views wrap access to the~inner data presentation elements to separate the~layers properly. 


%	------------------------------------------------------------------------ GUI ----------------------------------------------------------------------%
\label[realization.gui]
\sec GUI

Implementation of the~\glref{GUI} is based on the~final design described in section \ref[design.gui.the_final_design] on page \pgref[design.gui.the_final_design]. While following the~designed concept, also platform specific rules as mentioned in section \ref[analysis.android_platform.material_design] on page \ref[analysis.android_platform.material_design] were applied where possible. Following the~Material Design was a~secondary goal, since the~safety of the~driver is the~most important goal. Therefore compromises had to be made and they will be discussed later in this section. The final result is shown in figure \ref[realization.gui.final].

\medskip
\centerline{
\clabel[realization.gui.final]{Final GUI implementation}
\inspic images/realization_gui_final.png }\nobreak\medskip
\caption/f Final GUI implementation

\label[realization.gui.common_elements]
\secc Common elements

\seccc Colors

As described in section \ref[design.gui.the_final_design], two color modes are present -- so called themes. One consists of a~white font, gray secondary icons and a~black background, while the~other consists of a~black font, gray secondary icons and a~white background.

\seccc Sizes

While the~Material Design (\ref[analysis.android_platform.material_design]) suggests certain measures, they are not suitable for a~car environment as the~control and presentation elements would be too small. Therefore sizes are adjusted and much larger.

\seccc Effects

Trying to follow the~Material Design principles (\ref[analysis.android_platform.material_design]), several graphical effects are present in order to increase the~overall attractivity. All the~modules support proper elevation with shadowing even with the~elevation increase when touching the~button. Also, a~ripple effect is present when the~module is touched, a~stronger ripple effect appears on a~longer touch. This gives a~user a~proper visual feedback making the~application more pleasant.

\seccc Quick menu

As mentioned in section \ref[realization.core.modules], a~quick menu is a~limited set of options for every module. It gets invoked by a~long touch on a~module. It separates the~rectangular module into four rectangular pieces, each containing a~button (as shown in figure \ref[realization.gui.quickmenu]).

\medskip
\centerline{
\clabel[realization.gui.quickmenu]{Quick menu in the~final GUI}
\inspic images/realization_gui_quickmenu.png }\nobreak\medskip
\caption/f Quick menu (2nd row, 3rd column) in the~final GUI

\seccc Icons

Given the~platform guidelines (\ref[analysis.android_platform.material_design]), it is easier to find proper icons for various actions. Material Design icons\fnote{available from \url{https://github.com/google/material-design-icons}} are frequently updated and more icons are added on demand. Should an~icon be missing currently, it has a~high chance of being created later. It also helps to use familiar icons, so that a~user does not have to learn more images and their meanings.

\label[realization.gui.multiple_designs]
\secc Multiple designs

As mentioned in section \ref[design.gui.the_final_design], there are two types of modules -- an~action module and a~display module. Both of these modules have separate implementation, while sharing common elements like colors, standard icons, fonts and effects, as mentioned earlier (\ref[realization.gui.common_elements]).

\seccc Action module

An action module is a~rectangular element consisting of a~large centered icon and a~title in the~bottom on background of the~opposite color to the~font color. The icon ensures recognizability, while the~title specifies the~module identity. The result can be visible in figure \ref[realization.gui.quickmenu] (except for the~quick menu it is full of action modules).

Such action module is meant to be pressed, not to display information. On press it performs some action, which may or may not give a~feedback, based on it's purpose. However, it always gives a~visual feedback (\ref[realization.gui.common_elements]).

\seccc Display module

A~display module is also a~rectangular element, however it consists of a~large centered value text, a~title on top, a~value in the~right bottom corner and a~small gray icon in the~left bottom corner. All of it is on background of the~opposite color to the~font color. The result can be seen in figure \ref[realization.gui.final] (all modules in the~first row are display modules as well as the~first and the~last module in the~second row).

Such display module serves as a~source of information for the~driver. It can display various data in a~well readable form, while preserving an~attractive design. It is able to display several types of data from numbers to short strings.

%------------------------------------------------------------------------ TESTING ------------------------------------------------------------------------%
\label[testing]
\chap Testing

This chapter is about testing and all that is related. Starting with a~section about testing the~code, it describes a~use of the~test-driven development via unit tests. Then a~heuristic testing is performed as a~main mean of testing without users and the~results are reviewed. Finally, the~testing with users is thoroughly described, as it consists of the~usage of a~real-world car simulator, it's preparations and an~elaborate evaluation of all the~gathered data including the~eye-tracking system and a~simulator log. During the~usability testing, A/B testing and a~Change Lane Test are performed.  

%	------------------------------------------------------------------------ Implementation ----------------------------------------------------------------------%
\label[testing.code]
\sec Code

As mentioned in section \ref[analysis.development_and_support_tools.tdd], the~application development aimed to follow the principles of the~test-driven development approach. This means that unit tests cover part of the~application functionality. They do not cover everything, as automating certain functionality (such as \glref{GUI} for example) might actually be more time-consuming than manual testing.

\label[testing.code.unit_testing]
\secc Unit testing

At first some difficulties have to be mentioned. As an~Android application is not usually being developed in an Android environment, the problem of accessing actual Android \glref{API} emerges. This means that writing proper unit tests gets complicated and it is often easier (when comes to simple applications) to test it manually. This goes against the test-driven development approach, however, amount of time was limited and automated tests for features dependent on Android \glref{API} will hopefully be implemented later.

Apart from that, unit tests were created for Android \glref{API} independent classes and methods, for example utility classes. JUnit\fnote{\url{http://junit.org}} framework was used, as it eases the test implementation process, which consists of creating a test class in a package according to the tested class or method, then creating test methods with a {\tt @Test} annotation. Such methods get invoked during the test phase of a build process. They contain assertions, which check input for it's validity (usually an~expected value and an~actual value are provided to the assertion). Every such assert command is then evaluated and the failed ones are presented to the developer.

This approach helped discovering a lot of hidden bugs. Even a small change, which seemingly does not influence the tested component, can actually cause errors, which then get caught by the unit tests (in the best case scenario). With a minimal effort this can save a lot of hard work looking for a flawed area of code.

\par\maybebreak 3.5cm
%	------------------------------------------------------------------------ GUI ----------------------------------------------------------------------%
\label[testing.heuristic]
\sec Heuristic testing

Heuristic testing is based on following a~certain set of rules. It is based on somebody's experience. It is a~speed process of checking the~user interface for common issues. However, it does not interpret a~user's activity. The following evaluation will use the~heuristic created by Jakob Nielsen, which consists of ten rules (following later in the~text).~\cite[Zikovsky2015_3]

For purpose of presentation, in further text there will be signs plus ($+$) and minus ($-$) used for interpreting positive (plus) and negative (minus) evaluations. Also, priorities will be stated next to the~rule violations in parentheses and they will be limited to the words {\it low}, {\it medium} and {\it high}. Also additional notes are present (for future use).

\secc Evaluation

\seccc Visibility of system state

\begitems \style p 
* No long-lasting operations present, every long-lasting operation happens in the~background without a~user knowing,
* issues might appear with a server synchronization, which is not implemented yet.
\enditems

\seccc Match between system and reality

\begitems \style p
* Icons match their real world models,
  \begitems \style p
  * car informative modules have a~car icon,
  * clock module has a~clock icon,
  * etc.
  \enditems
\enditems

\seccc Minimal responsibility and stress

\begitems \style m
* Missing confirmation prompt when removing a~module (irreversible operation) (high),
* missing confirmation prompt when editing a~module (irreversible operation) (high),
* missing proper edit option for shortcut modules (irreversible module addition operation) (high).
\enditems

\seccc Match with platform and common standards

\begitems \style p
* Material Design present where possible,
\style m
* Material Design not present where not suitable:
  \begitems \style m
  * icon size (too large) (small),
  * list controls (does not scroll fluently, but scrolls page by page) (small),
  * navigation is not done by a~navigation drawer, but rather a~file-system like style (small),
  * measures do not match the~standards (too large) (small),
  * platform back button does not work immediately after changing the~theme (medium).
  \enditems
\enditems

\seccc Error prevention

\begitems \style p
* Mandatory fields are properly highlighted,
* keyboard for text fields is limited based on the~given field type,
\style m
* Intent module is not properly tested before adding (medium).
\enditems

\seccc Look and see

\begitems
\style p
* User interface is simple and consistent,
\style m
* availability of a quick menu is not visible, a user must memorize it (medium),
* position in a~tree structure is missing, a user does not see which layer is he in (high). 
\enditems

\seccc Flexibility and effectivity

\begitems
\style p
* Basic settings are very simple,
\style m
* there is no advanced mode for advanced users (medium),
* there are no macros (small),
* there are no key shortcuts (small).
\enditems

\seccc Minimality

\begitems
\style p
* Only the~most important information are shown,
* the~concept is minimalistic,
* only a~single information displayed per module.
\enditems

\seccc Meaningful error lines

\begitems
\style p
\style m
* Only the~platform default error line is present (high),
* the~error line does not say what happened wrong (high),
* the~error line does not say how to prevent the~error from happening (high).
\enditems

\seccc Help and documentation

\begitems
\style m
* The documentation is very limited (high),
* the~inner help is missing (high),
* there is no context hint for input fields (medium).
\enditems

\secc Conclusion

Overall results are relatively positive. Several compromises which break the~platform standards had to be made for the~sake of safety during usage, but the~priority list is clear.

However, there are several missing supportive elements, such as prompts, error reports and hints. All of these are on the~to-do list for later implementation and hopefully it will be fixed before the~release of the~application.

\label[testing.users]
\sec Testing with users

The importance of proper testing is critical as a~driver cannot be distracted from driving. Any significant flaw in the~application design might prove to be fatal and it certainly is not the~intention. Therefore thorough testing must be performed in order to achieve the~desired level of reliability.


One of the~most commonly used approaches is the~usability testing, where usually several participants try to perform certain actions with an~application. This is done in a~development environment and watched by the~developers.


However, the \glref{GUI} is meant to be used in unusual conditions, therefore testing in a~development environment cannot cover usability tests well enough. Considering that, the~\glref{UI} evaluation follows commonly recognized rules about a~Car \glref{UI} testing - the~\glref{LCT} (Lane Change Test). Given the~issue of performing possibly dangerous tasks in live traffic, the~usability tests are performed in a~safe but realistic environment - in a~car simulator with real-drive scenarios.


Also, to see how the~application is doing in context of competition, thorough A/B testing is performed. This testing uses the~advantages of a~car simulator as well. The competition to be compared with is the~application Torque (\ref[analysis.existing_applications.torque]), which is currently one of the~most downloaded \glref{OBD}-supporting applications on Android market\fnote{\url{https://play.google.com/store/search?q=OBD&c=apps&hl=en}}.

As a~related application has been developed simultaneously for a~mobile platform~\cite[Hruby2016], testing was performed for both of these applications together. Therefore, preparations were made just once as well as some parts of actual testing, such as introduction and questionnaires. However, both platforms were tested by each user so that the~results are relevant. 

\label[testing.users.simulator]
\secc Simulator

While providing safety, a~car simulator has other advantages as well. It is equipped with a~set of cameras that track the~eye movement. It is then easy to find out where and for how long is a~user focusing his sight, which is really important for evaluating the~cognitive load. It is also easy to try out different scenarios with a~single click, not requiring to drive around looking for a~proper place.

\medskip
\centerline{
\clabel[testing.users.simulator.interior]{Simulator interior}
\inspic images/testing_users_simulator_interior.jpg
}
\nobreak\medskip
\caption/f Simulator interior
\medskip

The simulator is located in Albertov in Prague in the~building of the~Faculty of Transportation Sciences\fnote{\url{https://www.fd.cvut.cz/english/}}, \glref{CTU}. It is build from the~interior (\ref[testing.users.simulator.interior]) of a~\v Skoda Octavia car and surrounded by three screens. There are three computers as the~hardware background. One serves for computing the~physical mode, other one serves for visualizing and the~last one handles the~control and communication interface.

The data from the~simulator are broad-casted over serial line and they are limited to speed and revolutions per minute. However, they can supposedly be extended to a~wider area of information.

The control software is called ``CarDynamics'' (shown in \ref[testing.users.simulator.cardynamics]), it shows all kinds of data about the~current state of the~vehicle, such as speed, rounds per minute, steering wheel position, gear position, acceleration, position in a~world model and more. It contains several world scenarios -- highways, countryside or even small cities.

\medskip
\centerline{
\clabel[testing.users.simulator.cardynamics]{Screenshot from CarDynamics}
\inspic images/testing_users_simulator_sw.png
}
\nobreak\medskip
\caption/f Screenshot from CarDynamics
\medskip

As mentioned above, there is also an~eye-tracking system. This enables the~tester to precisely determine when and how often a~user looks at the~application, on the~road or elsewhere. The system consists of two EyeTracker cameras and a~complex software called Smart Eye Pro (see figure \ref[testing.users.simulator.smarteye]).

\medskip
\centerline{
\clabel[testing.users.simulator.smarteye]{Screenshot from Smart Eye Pro}
\inspic images/testing_users_simulator_smarteye.png
}
\nobreak\medskip
\caption/f Screenshot from Smart Eye Pro

\label[testing.users.preparations]
\secc Preparations

Before even starting to test with users, several preparations had to be made. This included implementing a~software that can emulate an~\glref{OBD} module to transfer data from the~simulator to the~application. Also cameras had to be prepared, because the~software is not flawless and proper eye tracking prove to be an~issue. Then, finally, scenarios could have been made for all the~tested situations.

\par\maybebreak 1.5cm
\seccc Software

As the~simulator broadcasts data through a~serial link, it is impossible to easily catch the~data in a~tablet and still have a~realistic scenario. Also an~\glref{OBD} module is expected to be used with the~application, therefore it is most suitable to emulate it. A~simple software has been developed in a~Java language for such task. It listens to the~serial link on a~certain port, translates these data into inner Java primitive types, since they are in the~C structure format. Then a~bluetooth connection is initialized and an~\glref{OBD} module's protocol is emulated in order to communicate with the~actual tablet application. This had to be optimized for Torque as well in order to have even conditions.

\seccc Cameras

After testing the~eye tracking cameras, a~new issue emerged. Those cameras were unable to track the~intended position of a~tablet, as it was too low. Moving the~tablet up did not help, therefore positions of the~cameras had to be adjusted. The cameras were moved, so that they can track the~eye when looking at the~tablet. However, they were no longer able to track eyes when following the~road. The test results had to be limited to looking at the~tablet or not looking at the~tablet.

\seccc Scenarios

As shown in table \ref[testing.users.preparations.scenario], the~testing schedule has been made containing multiple supportive tasks as well as two testing scenarios. While the~rest of schedule is shared across platforms, the~A/B and \glref{LCT} testing scenarios are unique for each platform, therefore more time is required.

\medskip
\clabel[testing.users.preparations.scenario]{Single user testing schedule}
\ctable{ccrl}{
  \bf Start & \bf End & \bf Duration [min] & \bf Content \crl
  00:00:00 & 00:05:00 & 5 & Introduction\cr
  00:05:00 & 00:10:00 & 5 & Pre-test questionnaire \cr
  00:10:00 & 00:25:00 & 15 & Instructions and EyeTracker setup \cr
  00:25:00 & 00:40:00 & 15 & Warm-up driving \cr
  00:40:00 & 00:55:00 & 15 & A/B testing \cr
  00:55:00 & 01:05:00 & 10 & \glref{LCT} testing \cr
  01:05:00 & 01:10:00 & 5 & Post-test questionnaire \cr
  01:10:00 & 01:15:00 & 5 & Debriefing \cr
}\caption/t Single user testing schedule
\medskip

The A/B testing scenario is simple. At first the~user drives the~route without any application, so that he gets to know it. Then he drives the~same route with application A (Torque), while being frequently asked to read out-loud the~speed and \glref{RPM}. The speed is to be read from the~first second with interval of 20 seconds, the~\glref{RPM} is to be read from the~tenth second with interval of 20 seconds. The \glref{RPM} and speed displays are located on different screens, so that the~user has to scroll from one to another. The same scenario goes for the~application B (CarDashboard). A and B applications switch places for every tester (B first, A~second or the~other way around). The metrics then are the~glance times for both applications.

The Lane Change Test (\glref{LCT}) scenario is similar, however only the~CarDashboard application is being tested. The driver is supposed to drive on a~highway until a~speed limit sign appears telling him to drive at 60 km/h. After a~while (approximately 3 minutes) an~object appears from nowhere 35 meters in front of the~driver in his lane. He is then supposed to turn to the~left lane and avoid the~object. During the~whole journey the~user is asked for RPM to be read from the~tablet application, so that he has to control the~application while driving. The metrics are avoiding the~object and reacting as fast as possible while using the~application. It measures how much the~application distracts the~driver and how much does it influence the~reaction time.  

\seccc World models

As there are multiple world models available, it is necessary to choose a~proper ones for the~given scenarios. Therefore several world models were tested and the~best ones were chosen. For the~AB testing, a~countryside with villages on the~route was chosen. It is the~most realistic model available, containing even traffic and so on. For the~\glref{LCT} testing a~highway world model without traffic is the~most suitable. However, it had to be edited, so that an~object could appear at a~given location when driver crosses a~certain radius. This object would appear seemingly randomly, but there were two fixed locations in an~environment, where every part of the~road looks the~same, which does not give the~driver anything to memorize. This ensures that the~driver is not prepared when the~object appears.

\seccc Questionnaires

A~Screener questionnaire was created in order to select participants. This questionnaire ensured that only relatively active drivers would participate. Also only smart-phone users were considered, as other drivers are not likely to use such a~device (smart-phone, tablet) while driving. It is based on three questions:
\begitems
* Are you a~smart-phone user?
* Are you a~driver?
* How many times per week do you drive?
\enditems

A~pre-test questionnaire was created in order to get some information about the~participant. The information provided would be anonymous and would only serve for statistics. It consists of six questions:
\begitems
* How old are you?
* What is your sex?
* How many kilometers you drive by a~car per year?
* Which operating system is your smart-phone running?
* Have you ever used smart-phone while driving?
* How often are you using your smart-phone while driving?
\enditems
This questionnaire also focuses on the~market demand -- trying to find out, if the~drivers tend to use their devices while driving. Again, it is assumed that by answering the~smart-phone questions, answers to similar tablet questions would be strongly related. Usually when a~person has a~smart-phone with a~certain operating system and also has a~tablet, the~operating system on the~tablet is the~same. This simplifies the~questionnaire and does not overload the~participant, as the~participation was voluntary and without payment.

A~post-test questionnaire serves to find out how satisfied are the~participants with the~application and the~testing process itself. It consists of following the~five questions, some of which are to be rated from 1 to 5, where 1 is the~best:
\begitems
* What is your impression of using the~device while driving? (1-5)
* Were the~goals clear for you? (Yes/No)
* How acceptable was the~way of solutions for given tasks? (1-5)
* Was the~amount of displayed information appropriate? (1-5)
* Would you use the~application in everyday driving? (Yes/No)
\enditems

\label[testing.users.process]
\secc Process

After selecting (based on the~screener questionnaire) five participants \cite[Nielsen2012] and scheduling the~testing times, they were invited to come to the~Faculty of Transportation Sciences in Albertov, where the~simulator was located. There they filled the~pre-test questionnaire and begin the~actual testing based on the~schedule mentioned in section \ref[testing.users.preparations].

After eye-tracking setup was done and once the~participant felt comfortable with the~simulator (after driving for a~while in the~warm-up phase), the~scenarios took their place. The eye-tracking and simulator logging was turned on as the~participant accomplished all the~given tasks.

A~post-questionnaire was filled and the~testing was over. This was done for all five participants. Approximately 3 gigabytes of plain text data were collected from both the eye-tracking and the simulator logging.

\label[testing.users.evaluation]
\secc Questionnaire evaluation
%
%\seccc Screener questionnaire
%
%As the~results of screener questionnaires show \rfc{ priloha}, from 20 potential participants, only 9 were active drivers, who drive at least once a~week and use a~smartphone. While 4 potential participants were not drivers at all, another 5 said they did drive truly occassionally (once a~month and less). Another 3 were not smartphone users and therefore not suitable for the~testing. 

\seccc Pre-test questionnaire

Both men and women participated in the~testing, in age range from 22 to 45 years with the~mean of 28 and standard deviation of 9.62. The kilometers per year driven by the~participants were in range from 4000 to 30000 with the~mean of 14800 and the~standard deviation of 10849. As for the~smart-phone operating systems, all the~most commonly used were present. With Windows Phone and iOS both appearing once, the~Android OS was present with 3 participants. All of the~participants confessed to having used the~smart-phone while driving at least once, with 3 of them confessing to use it often. The other 2 confessed to using the~smart-phone only occasionally.

\seccc Post-test questionnaire

While the~goals appeared to be clear for all the~participants, not all were entirely happy with the~application. The overall satisfaction with the~application was in range from 1 to 3 out of 5 with the~mean of 1.8 and the~standard deviation of 0.8366 and the~acceptability of the~ways of solutions for given tasks was also in range from 1 to 3, also with the~mean of 1.8, however with the~standard deviation of 0.7582. The participants expressed satisfaction with the~amount of information displayed, as the~grades were in range from 1 to 2 with the~mean of 1.2 and the~standard deviation of 0.4472. At last, 4 out of 5 participants would use the~application in everyday driving.  

\secc A/B testing evaluation

The A/B testing is a~testing of the~Torque versus the~CarDashboard in even conditions. The participant drives while frequently being asked to read information of the~screen (as described in section about scenarios \ref[testing.users.preparations]). The eye-tracking system tracks the~eye movement and logs every 16.6 milliseconds if the~driver is looking at the~tablet or not at the~given moment. This ensures certain precision and reliability of results.

Logs have been examined and several outcomes measured. As first the~comparison of glance frequency will be shown. Then some statistical data are measured, such as confidence intervals and such. An overall comparison is created. Then duration of glance time is examined and compared for both applications. A maximal glance time and an~average glance time are compared as well as a~mean and a~standard deviation.

\seccc Glance frequency

Glance distribution in log files for Torque is visible in figure \ref[testing.users.ab.glance_torque]. The X axis contains the~individual log entries while the~Y axis adds 1 per each user looking at the~application at the~given moment. The log entries are limited from 5000 to 10000 and added together, as shown on the~R script below (the initialization script is shown in \ref[script.initialization]).

\label[testing.users.glance_script]
\begtt
addedData <- c()
for(i in 5000:10000){
  counter = 0
  for(j in 1:5){
    counter = counter + data[[j]]$Tablet[[i]]
  }
  addedData <- c(addedData, counter)  
}
barplot(addedData)
axis(1)
\endtt

\par\maybebreak 3.5cm
\centerline{
\clabel[testing.users.ab.glance_torque]{Glances for Torque}
\inspic images/testing_users_ab_glance_torque.png
}
\nobreak\medskip
\caption/f Glances for Torque

\medskip
\centerline{
\clabel[testing.users.ab.glance_cd]{Glances for CarDashboard}
\inspic images/testing_users_ab_glance_cd.png
}
\nobreak\medskip
\caption/f Glances for CarDashboard
\medskip

These are just illustrative plots to see the~portion of time looking at the~application (the black area of the~plot) and not looking at the~application (the white area of the~plot). The glance distribution in log files for CarDashboard is visible below the~Torque image for better comparison (\ref[testing.users.ab.glance_cd]).

While the~individual percentage ratio of time spent looking at the~Torque is in range from 13 to 18 percent with the~mean of 15.55 and the~standard deviation of 2.19, the~same for CarDashboard is only in range from 6 to 8 percent with the~mean of 7.45 and the~standard deviation of 1.32. The average percentage ratio of time spent looking at the~Torque is then 15.55 \%, while for CarDashboard it is only 7.40 \%. The R script for the~average time ratio is shown below, the~R scripts for individual (per participant) data are shown in \ref[script.glance_ratio_max_all].

\begtt
glanceLength = 0
glanceSum = 0
for(j in 1:5){
  glanceLength = glanceLength + length(data[[j]]$Tablet)
  glanceSum = glanceSum + sum(data[[j]]$Tablet)
}
print(100 * glanceSum / glanceLength)
\endtt  

\seccc Glance time

As another important metric, the~maximal glance time (the longest continuous time interval spent looking at the~application) measured for Torque was in range from 817 to 1616 milliseconds with the~mean of 1263.3 and a~standard deviation of 296.11. The same was measured for CarDashboard and the~results for the~maximal glance time are in range from 450 to 1217 milliseconds with the~mean of 716.7 and a~standard deviation of 298.38. This means that the~average maximal glance time for CarDashboard is nearly half the~average maximal glance time for Torque.

As mentioned by Daniel McGehee~\cite[McGehee2014], drivers tend to try obtaining the~required information for 1.5 to 2 seconds, then they give it up for the~moment and try again later. The 1.5-2 seconds glance time is also considered to be the~safety limit for a~single task requiring a~visual focus. With the~CarDashboard exhibiting maximal glance times lower than 1.2 second, the~limit of 1.5 second is not even reached which is a~success. 

Furthering the~glance time analysis, all the~log entries were combined into one (as shown in R script in the~addition \ref[script.glance_times_list]). Based on Student's t-test, there is 1 \% chance that the~driver will be looking continuously at the~Torque application for more than 157.67 milliseconds. For CarDashboard there is 1 \% chance of looking at the~application for more than only 109 milliseconds. Both of the~results from the~t-test performed in R are shown in the~additions (\ref[script.t_test_torque] and \ref[script.t_test_cd]), the~result for CarDashboard is shown below for illustration.

\begtt
t.test(glanceList, alternative="less", conf.level=0.99)

        One Sample t-test

data:  glanceList
t = 24.935, df = 983, p-value = 1
alternative hypothesis: true mean is less than 0
99 percent confidence interval:
     -Inf 108.5484
sample estimates:
mean of x 
 99.27168 
\endtt

With the~average glance time being 143.926 milliseconds for Torque, the~CarDashboard appears to perform much better with it's average glance time of 99.27 milliseconds. The glance times for Torque are shown on figure \ref[testing.users.ab.torque_glance_times], the~glance times for CarDashboard are shown below the~Torque figure on figure \ref[testing.users.ab.cd_glance_times]. 

\medskip
\centerline{
\clabel[testing.users.ab.torque_glance_times]{Torque glance times}
\inspic images/testing_users_ab_torque_glance_times.png
}
\nobreak\medskip
\caption/f Torque glance times

\medskip
\centerline{
\clabel[testing.users.ab.cd_glance_times]{CarDashboard glance times}
\inspic images/testing_users_ab_cd_glance_times.png
}
\nobreak\medskip
\caption/f CarDashboard glance times
\medskip

From further analysis it appears, that the~distribution of glance times is exponential. Should this assumption be correct, the~probability of looking at the~application for longer time would decrease exponentially. The comparison plot used for determining the~distribution is shown in image \ref[testing.users.ab.cd_glance_distribution], it is a~result of the~R script shown below.

\begtt
xMean = mean(glanceList) 
xSd = sd(glanceList)
a = xMean - sqrt(0.25)
b = a~+ xSd * sqrt(11.75)
hist(glanceList, prob = 1)
xWidth=max(glanceList) - min(glanceList)
xGrid=seq(min(glanceList) - 0.2 * xWidth, 
                 max(glanceList) + 0.2 * xWidth, length = 30)
lines (xGrid,dnorm(xGrid, mean = xMean, sd = xSd), 
         col = 'red', lw = 2, lty = 2)
lines (xGrid,dunif(xGrid, min = a, max = b), 
         col = 'blue', lw = 2, lty = 2)
lines (xGrid,dexp(xGrid, rate = 1 / xMean), 
         col = 'green', lw = 2, lty = 2)
\endtt

\medskip
\centerline{
\clabel[testing.users.ab.cd_glance_distribution]{Glance times distribution}
\inspic images/testing_users_ab_cd_glance_distribution.png
}
\nobreak\medskip
\caption/f Glance times distribution
\medskip

\secc Lane Change Test evaluation

As described in scenario (\ref[testing.users.preparations]), every participant drove for approximately 3 minutes in the~speed of 60 kilometers per hour, when the~object appeared from nowhere 35 meters in front of the~car. The object was a~yellow cube with 2.2 meters long side and a~red arrow pointing to the~left lane. This suggested the~driver to go around the~object by changing the~lane to the~left one.

\seccc Object avoidance

The most important metric in the~Lane Change Test is avoiding the~object while working with the~application. Every participant managed to avoid the~object, from which we can assume the~success rate around 100 \% (the success rate of the~testing is 100 \%, however it can be safely stated that nothing is perfect and real 100 \% in every situation possible is not achievable).

\seccc Reaction time

\medskip
\centerline{
\clabel[testing.users.clt.angles_p1]{Path angles of the~first participant}
\inspic images/testing_users_clt_angles_p1.png
}
\nobreak\medskip
\caption/f Path angles of the~first participant (0.1 meters point distance)
\medskip   

The second metric is the~reaction time. A reaction is determined from the~path of the~vehicle. The beginning of a~turning of a~car is considered as the~start of the~actual reaction. The turning is determined from significantly increasing the~angle between subsequent vectors in the~path. This is done by creating pairs of subsequent vectors from trinities of subsequent points. Experimentally, it was discovered (for the~measured data see example in figure \ref[testing.users.clt.angles_p1] based on the~script \ref[scripts.testing.clt.angles]) that an~angle of 0.2 degrees is significant enough to determine the~turn. The exact results are visible in table \ref[testing.users.clt.table_turn_coordinates], the~visual comparison is visible in the~related figure \ref[testing.users.clt.turn_paths]. %The scripts for such measurements are in the~additions \rfc{add} as well as the~angle plots \ref[]\rfc{add}.

\medskip
\clabel[testing.users.clt.table_turn_coordinates]{Results of path angle comparison}
\ctable{ccc}{
  \bf Color & \bf Turn coordination X & \bf Turn coordination Y \crl
  black & -5265.919 & 2294.193 \cr
  red & -5267.260 & 2293.928 \cr
  blue & -5266.978 & 2293.958 \cr
  green & -5262.808 & 2293.958 \cr
  yellow & -5263.845 & 2293.725 \cr
}\caption/t Results of path angle comparison
\medskip

\medskip
\centerline{
\clabel[testing.users.clt.turn_paths]{Turn paths}
\inspic images/testing_users_clt_paths.png
}
\nobreak\medskip
\caption/f Turn paths
\medskip   

Given the~results, a~reaction time can be measured. As described by Marc Green~\cite[Green2013], reaction time consists of three parts, which are highly situation-dependable and unexact. These parts are as follows:
\begitems
* {\bf Mental processing time} -- the~amount of time it takes for brain to perceive a~signal and to decide upon a~response,
* {\bf movement time} -- the~amount of time it takes to perform a~response (using muscles),
* {\bf device response time} -- the~amount of time it takes for a~vehicle to react to an~input.
\enditems

For the~purpose of evaluating, the~reaction time will be assumed to be a~single value without dividing it into three parts. A~note has to be made that the~simulator reaction delay is much lower than a~real vehicle delay, therefore a~device response time is minimized. When driving at 60 kilometers per hour, it is approximately the~speed of 16,667 meters per second. The times of reaction were measured based on the~speed and the~traveled distance from the~moment of an~object appearance. The measured times and the~distances (from the~object) of turns are shown in table \ref[testing.users.clt.turn_distances_times], an illustration is shown in figure \ref[testing.users.clt.car_path].

\medskip
\clabel[testing.users.clt.turn_distances_times]{Times and distances of turn from the~object}
\ctable{crr}{
  \bf Participant & \bf Turn distance [m] & \bf Turn time [ms] \crl
  P1 & 8.29 & 497.4 \cr
  P2 & 6.97 & 418.4 \cr
  P3 & 7.25 & 435.1 \cr
  P4 & 11.41 & 684.6 \cr
  P5 & 10.39 & 623.6 \cr
}\caption/t Times and distances of turn from the~object\medskip

\medskip
\centerline{
\clabel[testing.users.clt.car_path]{Car path}
\inspic images/testing_users_clt_car_path.png
}
\nobreak\medskip
\caption/f Car path
\medskip

%\href{http://www.humanbenchmark.com/tests/reactiontime}
%\href{	http://hfast.mie.utoronto.ca/wp-content/uploads/Publications/DAddario_Pamela_M_201403_MASc_thesis_final.pdf}{ odkaz v bibli: keyword: Fitch, Olson}
According to the statistical data gathered so far on a~human benchmark page\fnote{available at \url{http://www.humanbenchmark.com/tests/reactiontime}}, where participants push the~button when it turns green (knowing it will do so) five times over, the~average human reaction time for highly expected signal is 215 milliseconds. While the~participants in the~change lane test did expect something to happen and that they will have to go around something, they drove for three minutes focusing on keeping the~speed as well as controlling the~tested application in a~homogeneous environment of highway in the~forest, which heavily lowers their alertness. However, the~results are still under 0.7 second with the~mean of 531 milliseconds. As described in a~master's thesis by Pamela M. D'Addario~\cite[DAddario2014], a~similar test was performed focusing on alerted obstacle crash avoidance. Alerted means that the~participants knew what is the~test about. The measured mean time was 0.78 seconds. Another similar test was performed also with average results around 0.7 seconds. This means that the~application controlling in the~change lane test did not influence the~participant's awareness. The results are even slightly better than the~ones from the~tests mentioned above, but it can be caused by the~difference of measured signals -- the~accelerator pedal vs. steering wheel movement, as the~steering wheel movement is usually performed faster. Also, the simulator has much lower reaction delay than a real vehicle.

%	------------------------------------------------------------------------ Summary ----------------------------------------------------------------------%
\label[testing.summary]
\sec Summary

Thanks to automated testing, the~amount of bugs that got into the~release version was limited. The unit tests prevented many bugs from flowing through. However, certain bugs and imperfections were present in the~tests as well, allowing dysfunctional code go past them. The test-driven development just adds another layer to the~application development protection layer, but it is not perfect.

After the~development of the~graphical user interface was done, the~heuristic testing came into place. Many shortcomings have been found, however, not all were fixed because of the~thesis deadline. They will surely be fixed as soon as possible, as the~application will be released into the~real market and it has to be nearly perfect by then. The heuristic testing however gives a~great insight into certain areas of the~user interface.

Then even with a~few difficulties, the~application was tested in the~most suitable environment available -- a~real-world car simulator. Thanks to the~eye-tracking and the~simulator logs huge amount of data had been gathered. The evaluation of these data was done using the~R software.

The A/B testing against the~potential competitor -- Torque was performed. The tests have shown that the~CarDashboard performs better in the~real life scenarios based on obtaining information from a~car.

The Lane Change Test was done in order to find out the~influence of reaction time when using the~application. None or a~minor influence (in terms of units of milliseconds) has been found, from which one can assume that the~application usage is as safe as planned.

Overall the~testing was successful and it helped developing a~good and safe application for in-car environment. The testing participants were usually happy with the~way the~application is done and most of them claimed that they would use the~application daily.

%------------------------------------------------------------------------ CONCLUSION ------------------------------------------------------------------------%
\label[conclusion]
\chap Conclusion

In this chapter, first the assignment completion will be reviewed (fulfillment will be described for every single point of the~assignment). Information about the project life cycle, it's present and future will follow. Finally the thesis will be reviewed followed by a personal opinion and experience.

%	------------------------------------------------------------------------ Assignment completion ----------------------------------------------------------------------%
\label[conclusion.assignment_completion]
\sec Assignment completion

\secc Completing the~assignment tasks

\seccc Review existing Android applications for in-car use

The reviewed applications are described in section \ref[analysis.existing_applications]. There are the~following applications: Torque, CarHome Ultra, Car Dashdroid, Ultimate Car Dock. Also Android Auto was briefly described, as it is the~current direction of Google in the~automotive area.

\seccc Review and analyze User Interface development methods for in-car infotainment applications

A~\glref{GUI} is analyzed in section \ref[analysis.gui]. This analysis contains requirements for \glref{GUI} (\ref[analysis.gui.basic_principles]) as well as differences for the~in-car usage (\ref[analysis.gui.ui_in_a_car_environment]). It also describes the~development process (method) of a~user interface in section \ref[analysis.gui.development_process].

\seccc Analyze the~in-car OBD API and exported data

The \glref{OBD} is analyzed in section \ref[analysis.obd]. The \glref{API} is then described in section \ref[analysis.obd.api] and the~data are described in \ref[analysis.obd.data]. The \glref{OBD} is also mentioned in the~realization chapter in section \ref[realization.core.obd].

\seccc Design an~application system architecture for accessing the~OBD data and resources

The application architecture is described in section \ref[design.application_architecture], where the~limitations of the~platform architecture (\ref[design.application_architecture.platform_limitations]), the~extensibility (\ref[design.application_architecture.extensibility]), the~modularity (\ref[design.application_architecture.modularity]) and the~adaptability (\ref[design.application_architecture.adaptability]) are described.

\seccc Design a~tablet User Interface for in-car use

The process of designing the~tablet User Interface for in-car use is described in the~design section \ref[design.gui]. It presents four phases of \glref{GUI} creation process and the~emergence of the~final \glref{GUI} design.

\seccc Design and implement in-car application offering the~OBD data for Android tablet platform

The application development phase is described in chapter \ref[realization] in sections \ref[realization.tablet] and \ref[realization.core]. The \glref{OBD} access itself is described in section \ref[realization.core.obd] while the~data are provided using modules described in section \ref[realization.core.modules].

\seccc Perform UI and application testing and evaluate results

The testing is described in chapter \ref[testing]. Both application (\ref[testing.code]) and \glref{UI} testing (\ref[testing.heuristic] and \ref[testing.users]) are present. The testing with users was performed on a~real-world car simulator and it is thoroughly described in section \ref[testing.users].


%	------------------------------------------------------------------------ Project life cycle ----------------------------------------------------------------------%
\label[conclusion.project_life_cycle]
\sec Project life cycle

\label[conclusion.project_life_cycle.present]
\secc Present

Currently the application is being prepared for release. As mentioned in the chapter about testing (\ref[testing]), some adjustments have to be made in order to fix all the issues. After this is done, the application will be releases to the Google Play Store\fnote{\url{https://play.google.com/store?hl=en}}.

\label[conclusion.project_life_cycle.future]
\secc Future

In the future, the application will be enhanced with additional functionality, statistics and so on. It is planned to implement a logging mechanism which will log interesting data on server. Those data can later be evaluated and presented to the user (for example his driving style can be evaluated, it can also serve as a path tracker and so on).

Also, the application can serve as a device for Internet of Things as a controller and/or a viewer. It can display simple information (such as home temperature) or even turn on lights, open the garage, play music, etc. Some of the functionality is already being tested, the application contains a few \glref{IoT} modules (temperature display and light switch).

%	------------------------------------------------------------------------ Summary ----------------------------------------------------------------------%
\label[conclusion.summary]
\sec Summary

The goal of this thesis has been achieved, however a lot of work is still left to be done. The CarDashboard application offers a simple graphical user interface and easy extendability, making it truly versatile. The car does not have to be the only environment the application can be used in. The next step can be smart homes or even factories, where precision and simplicity are necessary.

The thorough testing has shown overall success of development. The GUI appears to follow the intended path of safety while offering variable functionality. The tests have also shown certain level of satisfaction of the application users, which after all is one of the most important goals. 

I am really glad I had a chance to work with a wide area of technologies during this project. I had a chance to perform a proper testing with access to a car simulator, which is far better than what I could've imagined at the beginning. I used all kinds of statistical methods when evaluating the results and it was very interesting to see it from different points of view. 

I've learned a lot more about developing for Android. However imperfect it was, it is a great experience to have. Also trying the \glref{GUI} development process in practice is really interesting. During that I've learned some wonderful techniques from start to end.

And at last but not least, I've improved my research abilities, as I've reviewed several research papers and soon I might attempt to create one or two (in cooperation with Luk\' a\v s Hrub\' y) regarding this topic. Overall, this has been a great experience.

%------------------------------------------------------------------------ BIBLIOGRAPHY ------------------------------------------------------------------------%

\bibchap
\usebbl/c bibliography

% https://www.citacepro.com/dokument/b8tzUVgixHR9aGI3
% download .tex format
% insert into bibliography.bbl
% search and replace

%------------------------------------------------------------------------ APPENDIX / APPENDICES ------------------------------------------------------------------------%

%	------------------------------------------------------------------------ CD content ----------------------------------------------------------------------%
\app CD content

\begtt
|   readme.txt............................description of the CD content 
+---apk.....................folder containing the application .apk file
+---src..................................................sources folder
|   +---CarDashboard........................implementation source codes
|   \---MP_Blaha_Michael_2016..........................tex source codes
\---text.............................................thesis text folder
        MP_Blaha_Michael_2016.pdf..................thesis in PDF format
\endtt

%	------------------------------------------------------------------------ User's guide ----------------------------------------------------------------------%
\app User's guide

\sec Installation guide

\secc Prerequisites

\begitems
* application .apk installation file,
* Android tablet device,
* OBD-II Blue-tooth adapter (optional).
\enditems

\secc Installation process

\begitems \style n
* Copy the .apk file inside the Android device,
* execute the .apk file from the Android device file system,
* complete the installation process,
* insert OBD-II Blue-tooth adapter into the car (optional),
* pair device with the adapter via Blue-tooth (optional),
* launch the application (optional),
* go to settings (optional),
* connect the application to the adapter (optional).
\enditems

\par\maybebreak 3.5cm
\sec User guide

\medskip
\centerline{
\label[add.ug.app]
\inspic images/realization_gui_final.png }\nobreak\medskip
\caption/f Application GUI

As visible in figure \ref[add.ug.app], there are several rectangular modules visible. Interaction with a module is done using a single touch. For modules displaying some value, the touch causes the application to say the value out loud. For other modules it performs an action depending on the module type:
\begitems
* Folder module invokes a sub-folder (displays other modules),
* shortcut module invokes a different application or an intent,
* add module invokes a module selection screen for addition,
* back module goes back to the parent from sub-folder,
* other modules, such as light button module, can invoke certain action (based on their purpose).
\enditems

Navigation in application is done using a swipe to the left or right. This changes the screen to the right or to the left screen. Navigation to sub-folders is done via touching them, as mentioned earlier.

\par\maybebreak 3.5cm

\medskip
\centerline{
\label[add.ug.qm]
\inspic images/realization_gui_quickmenu.png }\nobreak\medskip
\caption/f Application GUI with Quick menu (2nd row, 3rd column)
\medskip

There is also a feature called ``Quick menu'' for almost every module (with exception of back modules and add modules). The Quick menu is invoked by a long touch. As shown in figure \ref[add.ug.qm], the touched module divides itself into four separate buttons containing basic features - cancel, delete and edit.

Adding a module is done via the add module (module with a plus icon). This invokes a list of available modules (divided into few sections). Some modules can require additional settings before being added. Such module is an intent module or an application shortcut module.




%	------------------------------------------------------------------------ Glossary ----------------------------------------------------------------------%
\app Glossary\par \makeglos

%	------------------------------------------------------------------------ Images ----------------------------------------------------------------------%
\app Images

\medskip
\centerline{
\clabel[app.design.gui.draft3]{Music player GUI draft}
\inspic images/design_gui_draft3.png
}
\nobreak\medskip
\caption/f Music player GUI draft
\medskip

\centerline{
\clabel[app.design.gui.draft4]{Music playlist GUI draft}
\inspic images/design_gui_draft4.png
}
\nobreak\medskip
\caption/f Music playlist GUI draft
\medskip

\medskip
\centerline{
\clabel[app.design.gui.draf1_impl]{Implementation of the~first draft}
\inspic images/design_gui_draft1_impl.png
}
\nobreak\medskip
\caption/f Implementation of the~draft image \ref[design.gui.draft1]
\medskip


\medskip
\centerline{
\clabel[app.design.gui.draft9]{The grid with a~music player panel and measurements}
\inspic images/design_gui_draft9.png
}
\nobreak\medskip
\caption/f The grid with a~music player panel and measurements
\medskip


\centerline{
\clabel[app.test.ab.torque_glance_distribution]{Glance times distribution for Torque}
\inspic images/add_test_ab_torque_glance_distribution.png
}
\nobreak\medskip
\caption/f Glance times distribution for Torque

%	------------------------------------------------------------------------ Tables ----------------------------------------------------------------------%
\app Tables

\clabel[tables.testing.ab]{A/B testing}
\ctable{clclc}{
& \multispan2\hss\bf Torque \hss \tabstrut & \multispan2\hss\bf CarDashboard\hss \tabstrut \crl
\bf Participant & \bf Glance ratio & \bf Max glance time & \bf Glance ratio  & \bf Max glance time \crl
P1 & 18.63329 \% & 1300 ms & 8.291183 \% & 633 ms \cr
P2 & 15.71007 \% & 1617 ms & 5.478639 \% & 450 ms \cr
P3 & 13.1708 \% & 817 ms & 7.768305 \% & 550 ms \cr
P4 & 13.76879 \% & 1283 ms & 8.866204 \% & 733 ms \cr
P5 & 16.47285 \% & 1300 ms & 6.895412 \% & 1216 ms \cr
Mean & 15.55116 \% & 1263 ms & 7.459949 \% & 717 ms \cr
S. deviation & 2.191875 \% & 286.1138 ms & 1.32362 \% & 298.3752 ms \cr
}
\caption/t A/B testing

%	------------------------------------------------------------------------ Scripts ----------------------------------------------------------------------%
\app Scripts

\label[script.initialization]
{
\begtt
data <- list()
data[[1]] <- fread("../usability tests/p1_t_ab_torque.log", 
                     select = c("ClosestWorldIntersection.objectName"))
data[[2]] <- fread("../usability tests/p2_t_ab_torque.log", 
                     select = c("ClosestWorldIntersection.objectName"))
data[[3]] <- fread("../usability tests/p3_t_ab_torque.log", 
                     select = c("ClosestWorldIntersection.objectName"))
data[[4]] <- fread("../usability tests/p4_t_ab_torque.log", 
                     select = c("ClosestWorldIntersection.objectName"))
data[[5]] <- fread("../usability tests/p5_t_ab_torque.log", 
                     select = c("ClosestWorldIntersection.objectName"))
for(i in 1:5){
  data[[i]][data[[i]]!="tablet"] <- 0
  data[[i]][data[[i]]=="tablet"] <- 1
  names(data[[i]])[names(data[[i]])=="ClosestWorldIntersection.objectName"] 
      <- "Tablet"
  data[[i]]$Tablet <- as.numeric(data[[i]]$Tablet)
}
\endtt
}\caption/f Initial script for loading and preparing the~data
\medskip

\label[script.glance_times_list]
{
\begtt
glanceList <- c()
counter = 0
for(j in 1:5){
  for(i in 1:length(data[[j]]$Tablet)){
    val = data[[j]]$Tablet[[i]]
    if(val == 0){
      if(counter > 0){
       # multiplied by 1000/60 because of the~log entry frequency  
       #  -> 1000/60 milliseconds
        glanceList <- c(glanceList, counter * 1000 / 60)
        counter = 0 
      } 
    } else {
      counter = counter + 1
    }
  }
}
if(counter > 0){
  glanceList <- c(glanceList, counter * 1000 / 60)
}
\endtt
}\caption/f Creating list of glance times
\medskip

\label[script.glance_ratio_max_all]
{
\begtt
eval <- list(c(),c())
for(j in 1:5){
  ratio = sum(data[[j]]$Tablet) / length(data[[j]]$Tablet)
  max = 0
  counter = 0
  for(i in 1:length(data[[j]]$Tablet)){
    val = data[[j]]$Tablet[[i]]
    if(val == 0){
      if(max < counter){
        max = counter
      }
      counter = 0  
    } else {
      counter = counter + 1
    }
  }
  eval[[1]] <- c(ratio * 100, eval[[1]])
  eval[[2]] <- c(max * 1000 / 60, eval[[2]])
  print(ratio * 100)
  print(max * 1000 / 60)
}
mean(eval[[1]])
sd(eval[[1]])
mean(eval[[2]])
sd(eval[[2]])
\endtt
}\caption/f Evaluating glance ratio and max glance time for all the~participants
\medskip

\label[script.t_test_torque]
{
\begtt
> t.test(glanceList, alternative="less", conf.level=0.99)

        One Sample t-test

data:  glanceList
t = 24.39, df = 1360, p-value = 1
alternative hypothesis: true mean is less than 0
99 percent confidence interval:
     -Inf 157.6701
sample estimates:
mean of x 
  143.926 

> t.test(glanceList, conf.level=0.99)

        One Sample t-test

data:  glanceList
t = 24.39, df = 1360, p-value < 2.2e-16
alternative hypothesis: true mean is not equal to 0
99 percent confidence interval:
 128.7046 159.1475
sample estimates:
mean of x 
  143.926 
\endtt
}\caption/f Confidence intervals for Torque glance times
\medskip

\label[script.t_test_cd]
{
\begtt
> t.test(glanceList, conf.level = 0.99, alternative="less")

        One Sample t-test

data:  glanceList
t = 24.935, df = 983, p-value = 1
alternative hypothesis: true mean is less than 0
99 percent confidence interval:
     -Inf 108.5484
sample estimates:
mean of x 
 99.27168 

> t.test(glanceList, conf.level = 0.99)

        One Sample t-test

data:  glanceList
t = 24.935, df = 983, p-value < 2.2e-16
alternative hypothesis: true mean is not equal to 0
99 percent confidence interval:
  88.99696 109.54640
sample estimates:
mean of x 
 99.27168 
\endtt
}\caption/f Confidence intervals for CarDashboard glance times
\medskip


\label[scripts.testing.clt.angles]
{
\begtt
startX <- c()
startY <- c()

angles <- list(c(),c(),c(),c(),c())
xpoints <- list(c(),c(),c(),c(),c())
ypoints <- list(c(),c(),c(),c(),c())

for(column in 1:5){
  printedA = 0
  printedB = 0
  xlimA = 0
  xlimB = 0
  for(i in 1:length(data[[column]]$V3)){
    if(printedA == 0){
      if(data[[column]]$V3[[i]] >= (-5239.3-35)){
        print(i)
        xlimA = i
        printedA = 1
      }
    } else {
      if(printedB == 0){
        if(data[[column]]$V3[[i]] >= (-5239.3)){
          print(i)
          xlimB = i
          printedB = 1
        }
      } else {
        break
      }
    }
  }

  space = 0.1
  xCoord = 0
  x1 = 0
  x2 = 0
  x3 = 0
  y1 = 0
  y2 = 0
  y3 = 0
  for(i in xlimA:xlimB){
    if(xCoord == 0){
      x1 = data[[column]]$V3[[i]]
      y1 = data[[column]]$V5[[i]]
      xCoord = x1
      xpoints[[column]] <- c(xpoints[[column]], x1)
      ypoints[[column]] <- c(ypoints[[column]], y1)
    } else {
      xCoord2 = data[[column]]$V3[[i]]
      if(abs(xCoord - xCoord2) < space){
      } else {
        if(x2 != 0){
          x3 = data[[column]]$V3[[i]]
          y3 = data[[column]]$V5[[i]]
          xCoord = x3
          xpoints[[column]] <- c(xpoints[[column]], x3)
          ypoints[[column]] <- c(ypoints[[column]], y3)
          ux = x2 - x1
          uy = y2 - y1
          vx = x3 - x2
          vy = y3 - y2
          top = ux * vx + uy * vy
          bot = sqrt(ux * ux + uy * uy) * sqrt(vx * vx + vy * vy)
          angles[[column]] <- c(angles[[column]], acos(top/bot)*180/pi)
          x1 = x2
          y1 = y2
          x2 = x3
          y2 = y3
        } else {
          x2 = data[[column]]$V3[[i]]
          y2 = data[[column]]$V5[[i]]
          xCoord = x2
          xpoints[[column]] <- c(xpoints[[column]], x2)
          ypoints[[column]] <- c(ypoints[[column]], y2)
        }
      }
    }
  }


  angles[[column]][is.nan(angles[[column]])] <- 0

  for(i in 1:length(angles[[column]])){
    if(angles[[column]][[i]] > 0.2){
      print(xpoints[[column]][[i+1]])
      print(ypoints[[column]][[i+1]])
      print(i)
      startX <- c(startX, xpoints[[column]][[i+1]])
      startY <- c(startY, ypoints[[column]][[i+1]])
      break
    }
  }
}
plot(angles[[1]])
\endtt
}\caption/f Script for calculating the~path angles


\bye
