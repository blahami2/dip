% % % % % % % % % % % % %
% Example thesis (CTU FIT) based on CTUstyle 
% use: pdfcsplain <FIT-ZP.tex>
% write this document as UTF-8
% % % % % % % % % % % % %
% CTUstyle: see more at http://petr.olsak.net/ctustyle.html
% requirements: ctustyle.tex, ctulogo.pdf
% CTUstyle requires OPmac (opmac.tex)
% download OPmac from
% http://petr.olsak.net/opmac.html
% % % % % % % % % % % % %

% This example created by Ondrej Guth <ondrej.guth@fit.cvut.cz> 2014
% based on CTUstyle by Petr Olsak

% % % % % % % % % % % % % 
% The following not to be modified
% % % % % % % % % % % % % 
\input ctustyle
\faculty {F8}
% % % % % % % % % % % % % 
% Modify the following
% % % % % % % % % % % % %

% (thesis type {B,M,D})/(language {CZ,EN})
\worktype [M/EN]
\department {Katedra softwarového inženýrství}
\title {Tablet infotainment system}
\author {Bc. Michael Bl\' aha}
\date {January 2016}
\supervisor{Ing Jan \v Sediv\' y, CSc.}
\abstractEN {This document is for testing purpose only.}
\abstractCZ {Tento dokument je pouze pro pot{\v r}eby testování.}
\declaration {Prohla\v suji, \v ze jsem p\v redlo\v zenou pr\'aci vypracoval(a) samostatn\v e a \v ze jsem uvedl(a) ve\v sker\'e pou\v zit\'e informa\v cn\'\i{} zdroje v~souladu s~Metodick\'ym pokynem o~etick\'e p\v r\'\i{}prav\v e vysoko\v skolsk\'ych z\'av\v ere\v cn\'ych prac\'\i{}.

		Beru na v\v edom\'\i{}, \v ze se na moji pr\'aci vztahuj\'\i{} pr\'ava a povinnosti vypl\'yvaj\'\i{}c\'\i{} ze z\'akona \v c.~121/2000~Sb., autorsk\'eho z\'akona, ve zn\v en\'\i{} pozd\v ej\v s\'\i{}ch p\v redpis{\r u}, zejm\'ena skute\v cnost, \v ze \v Cesk\'e vysok\'e u\v cen\'\i{} technick\'e v~Praze m\'a pr\'avo na uzav\v ren\'\i{} licen\v cn\'\i{} smlouvy o~u\v zit\'\i{} t\'eto pr\'ace jako \v skoln\'\i{}ho d\'\i{}la podle \S{}~60 odst.~1 autorsk\'eho z\'akona.}


\picw=.8\hsize

\makefront



%----------------------------------------------------------------------- INTRODUCTION ------------------------------------------------------------------------%
\label[introduction]
\chap Introduction TODO

sources:
\begitems
* \url{https://docs.google.com/document/d/1pGtlS5uY4PdKfHjf83dFGrajyVcea0tvzAnwXf61Cs8/edit}
* generally progress: \url{https://docs.google.com/document/d/1CEWym7MphsCO0v3CXe_bTHOgFBgquBbPVbhk_pHZ5t8/edit}
\enditems

%	------------------------------------------------------------------------ Project ----------------------------------------------------------------------%
\label[introduction.project]
\sec Project TODO

See above

%		------------------------------------------------------------------------ Motivation ----------------------------------------------------------------------%
\label[introduction.motivation]
\secc Motivation TODO

See above

%	------------------------------------------------------------------------ Assignment analysis ----------------------------------------------------------------------%
\label[introduction.assignment_analysis]
\sec Assignment analysis

\secc Assignment tasks

\seccc Review existing Android applications for in-car use

One of the key approches in research project is reviewing the existing progress in the given field. Reviewing existing applications helps understanding the topic, seeing the bigger picture, learning from mistakes of others and last but not least, getting general idea about competition.

\seccc Review and analyse User Interface development methods for in-car infotainment applications

Cosindering the car environment, the user interface must deal with a lot of different problems than usual. This task should review existing User Interface development rules and apply them to the car environment, then analyse them and choose proper method for car-UI design process.

\seccc Analyze the in-car OBD API and exported data

On-Board Diagnostics API is a standard API provided by modern cars for gathering various information from speed to engine temperature. This task focuses on understanding and gathering data from the OBD API.

\seccc Design an application system architecture for accessing the OBD data and resources

Having the data from OBD and preparing an application for displaying them, designing proper architecture is required for everything to work well. The application has to gather data, while displaying them properly without unneccesary (TODO FIX!) delay.

\seccc Design a tablet User Interface for in-car use

After reviewing existing applications and UI development methods, the next goal is to create new User Interface for in-car use, while considering the constraints this environment puts on it.

\seccc Design and implement in-car application offering the OBD data for Android tablet platform

With everything prepared and thought through, the application will be developed based on result from all the tasks accomplished so far. In this case, the Android platform will be used as explained later in the text.

\seccc Perform UI and application testing and evaluate results

For best results the application must and will be tested. Both code and UI must be tested properly, using various testing approaches, such as unit tests or UI testing with reaul users in a car simulator.

%------------------------------------------------------------------------ ANALYSIS ------------------------------------------------------------------------%
\label[analysis]
\chap Analysis TODO

sources:
\begitems
* application analysis \url{https://docs.google.com/document/d/1QyOiMzV0ikcDhPY3P5MsRL_80cCGzjoGfCACGvc-UL0/edit}
* priority list \url{https://docs.google.com/document/d/1juKYgUUDSI5CmfzjR4BsYSPHVYCGqrWuejgbhqzw7kI/edit}
\enditems

%	------------------------------------------------------------------------ Existing applications ----------------------------------------------------------------------%
\label[analysis.existing_applications]
\sec Existing applications


\label[analysis.existing_applications.applications]
\secc Applications TODO

sources:
\begitems
* \url{https://docs.google.com/document/d/1p_pSGTUHEojOyP7ICCDNVV7RW1vn8iN_KECipC4Y9tY/edit}
* \url{http://www.makeuseof.com/tag/5-best-dashboard-car-mode-apps-android-compared/}
\enditems

\label[analysis.existing_applications.torque]
\secc Torque 

Starting with an empty screen, lot of settings are required before using this application, since there is no default mode. Adding new views is easy and intuitive, but still very confusing. The add menu lacks hierarchy and everything is just sorted array of various options. There is no cancel button when popping the menu dialog.

This application can actually show almost anything OBD provides. It supports differents types of display, but it is hard to tell by their names. Responsiveness it not smooth at all and launching the application in horizontal mode confuses it, everything behaves like if it was in vertical mode.


\medskip
\centerline{\inspic images/analysis_app_torque.png }\nobreak\medskip
\caption/f Screenshot from Torque

\seccc Advantages

\begitems
* Lot of data from OBD available,
* various layout settings and themes,
* HUD mode.
\enditems

\seccc Disadvantages

\begitems
* One-level confusing menu without hierarchy,
* limited size options for displays (3 types),
* lacks default mode with predefined displays,
* hard to place displays, the grid does not work well,
* slow and laggy.
\enditems

% screenshot

\label[analysis.existing_applications.carhome_ultra]
\secc CarHome Ultra 

This application starts with a pop-up tutorial for it's elementary functionality, telling the user about the speedmeter, compass, weather forecast and customizable dashboard for launching external applications. In default it offers Google Maps, Google Navigation and voice search. Adding another external application shortcut is done by tapping the tab. Also there are basic settings, which offer brightness mode (day, night, auto), theme and safety options.

It appears to be just a simple application offering speed, compass, weather and external application launcher. The new version also displays location (address) and a phone version is able to respond to text messages. It also supports text to speech (on touch).

\medskip
\centerline{\inspic images/analysis_app_carhomeultra.png }\nobreak\medskip
\caption/f Screenshot from CarHome Ultra

\seccc Advantages

\begitems
* Simple UI, easy to understand,
* responsive, fluent,
* possible to change units (mile/km, etc.),
* lot of themes available,
* adjustable update rates,
* a lot of different settings.
\enditems

\seccc Disadvantages

\begitems
* Small buttons on small screens (fixed 6 buttons),
* even smaller setting buttons
* limited functionality
* tapping weather makes the app speak for every single tap, no matter if it already speaks (it can speak for hours after few taps).
\enditems

\label[analysis.existing_applications.car_dashdroid]
\secc Car Dashdroid 

After a long loading the main window appears. It has three screens, which change by swiping right or left. The left screen contains dial keyboard, the right screen contains customizable cards (for external application shortcuts or built-in tools) and the main screen consists of weather, speed and shortcuts to contacts, music, navigation and voice command.

It also provides settings for bluetooth, brightness, screen rotation, fullscreen, day/night mode and application settings, where other options can be set, such as home adress, theme, units.

\medskip
\centerline{\inspic images/analysis_app_cardashdroid.png }\nobreak\medskip
\caption/f Screenshot from Car Dashdroid

\seccc Advantages

\begitems
* Simple UI, easy to understand,
* responsive, fluent,
* possible to change units (mile/km, etc.),
* able to read incoming SMS using TTS.
\enditems

\seccc Disadvantages

\begitems
* Very limited functionality
* not optimized for tablet,
* distractive commercial ads in free version.
\enditems

\label[analysis.existing_applications.ultimate_car_dock]
\secc Ultimate Car Dock 

While the design is very similar to CarHome Ultra, this application offers fewer displays on a single screen. There are five screens, each one consists of six cards. Every card can change into shortcut or a build-in application. The Ultimate Car Dock has only few built-in applications: music player, voice command, speed, weather, messages and calls. It also supports shortcuts to other external applications.

\medskip
\centerline{\inspic images/analysis_app_ultimatecardock.png }\nobreak\medskip
\caption/f Screenshot from Ultimate Car Dock

\seccc Advantages

\begitems
* Simple UI, easy to understand,
* responsive, fluent,
* possible to change units (mile/km, etc.),
* able to read various incoming notifications using TTS (Gmail, WhatsApp, etc.),
* predefined SMS responses (selectable when a message comes),
* direct calls and messages (shortcut to call/message a certain person).
\enditems

\seccc Disadvantages

\begitems
* Limited functionality
* not optimized for tablet,
* small font.
\enditems

\label[analysis.existing_applications.conclusion]
\secc Conclusion 

Except by Torque, which focuses mainly (and only) on OBD, all the applications are very similar to each other. They have similar design and functionality -- mostly weather, speed provided by GPS, voice command and shortcuts for external applications.

\seccc Suggestions

\begitems
* OBD data,
* shortcuts to other applications,
* adjustable cards,
* built-in cards (weather, speed, voice command, etc.),
* simple grid UI,
* possibility to change displayed units,
* responsive and fluent,
* day and night theme,
* predefined message and call responses,
* TTS for incoming notifications.
\enditems

\seccc Possible issues to avoid

\begitems
* Responsiveness,
* limited functionality,
* small and hardly visible font,
* distractive ads.
\enditems

\label[analysis.existing_applications.android_auto]
\secc Android Auto 

sources:
\begitems
* \url{http://developer.android.com/design/auto/index.html}
* \url{https://www.google.com/design/spec-auto/designing-for-android-auto/designing-for-cars.html}
\enditems

Recently, Google presented new application model for information delivery while driving. It is called Android Auto, it provides a standardized user interface and user interaction model for Android devices. Focusing on minimazing the driver distraction, it presents a few options to interact with user. It supports three application types:
\begitems
* System overview
* Audio applications
* Messaging applications
\enditems

\seccc System overview

System overview is supposed to be a home screen for Android Auto application. It presents both current and past notifications. The amount of notifications is limited based on screen size. Every notification consists of an intent icon, text and image, while following certain sizing rules. Every such notification can be expanded on the spot or another subapplication can be launched.

\medskip
\centerline{\inspic images/analysis_aa_overview.png }\nobreak\medskip
\caption/f Android Auto Home screen

\seccc Audio applications

Audio applications in Android Auto have a simple template structure. It consists of a main consumption view, a drawer and a queue screen. The main consumption view displays a few control elements and a cover background. The drawer is a simple list and provides access to favorite and popular content. Finally the queue screen displays a list of pending content, for example songs in a queue.

\medskip
\centerline{\inspic images/analysis_aa_audio.png }\nobreak\medskip
\caption/f Android Auto audio application

\seccc Messaging applications

Focusing on minimizing the cognitive load, messaging concept in Android Auto focuses on voice control over looking and typing. It allows reading the message outloud and responding with a set of predefined voice commands as well as dictating a whole message using built-in speech recognition.

\medskip
\centerline{\inspic images/analysis_aa_message.png }\nobreak\medskip
\caption/f Android Auto conversational flow

\seccc Conclusion

It seems to be a good sign that even Google is interested in this area and performs such a research. Every Android application can be designed for Android Auto and use it's simplified user interface, allowing the developer to focus on other issues than in-car user interaction. However, the functionality is currently very limited. Hopefully there will be further progress as soon as possible.

%	------------------------------------------------------------------------ Use cases ----------------------------------------------------------------------%
\label[analysis.use_cases]
\sec Use-cases

Based on above. Also other typical analysis stuff.

%	------------------------------------------------------------------------ Platforms ----------------------------------------------------------------------%
\label[analysis.platforms]
\sec Platforms

The chosen platform heavily influences the piece of market an application can reach. Therefore, only platforms with solid market share are considered. Another criteria is the simplicity of development, which influences the time and effort put into an application before it can be released. This is especially important for quickly finding out the sale potential of an application.

Following the first rule mentioned above and based on tablet sales in past years (sources: \url{http://techcrunch.com/2014/03/03/gartner-195m-tablets-sold-in-2013-android-grabs-top-spot-from-ipad-with-62-share/}), the only viable options for an application are platforms Android, iOS and Windows.

\label[analysis.platforms.android]
\secc Android

In 2013, the Android platform had 61.9 \% market share, making it the most used platform in the world. Targeting the Android platform would create large base of potential customers.

The development language for Android is Java, commonly known object-oriented programming language with solid developer base. Therefore it is easy to find developers as well as answers to variety of programming related issues, making the development much easier.

\label[analysis.platforms.ios]
\secc iOS

With 36 \% market share in 2013, iOS is the second most popular tablet platform. Considering a typical iOS user, who is willing to pay for quality, iOS could be a good choice for an application in context of potential customers.

However, the development language called Swift is somewhat new in the world, which brings a lot of possible difficulties. Searching for answers while developing in this technology might prove too troublesome.

\label[analysis.platforms.windows]
\secc Windows

With only 2.1 \% market share in 2014, the Windows platform does not seem to be a valid choise for given criteria. Having thirty times lower customer base than Android, it goes into the nice-to-have section when it comes to multi-platform applications.

\label[analysis.platforms.conclusion]
\secc Conclusion

Fulfiling the requirements for customer base as well as simplicity of development, the Android platform seems to be the best choice available at the time of writing this. As such, it will be analyzed more thoroughly later in this chapter.

%	------------------------------------------------------------------------ Android platform ----------------------------------------------------------------------%
\label[analysis.android_platform]
\sec Android platform TODO

There are some platform aspects to be considered when developing for Android-based tablet device. First is the problem with most of the tablet devices -- the device performance. While the hardware is continuously evolving, one must consider older devices as well as growing requirements for graphics presentation. The second possible issue is the Android architecture, which influences the application inner communication.

\label[analysis.android_platform.performance]
\secc Performance

Nearly with every new version of Android, new presentation effects are prepared for developers to use. While it is not mandatory, it is still adviced to hold the platform standards as the market demands it. The application must have a good look and feel in order to attract attention. This must be considered when building the application, because the environment demands fluent responses.

\label[analysis.android_platform.architecture]
\secc Architecture

The main building block in Android application is an activity. The activity is an idependent component of application, a hybrid between controller and view in MVC architecture. It contains a single screen (which contains a single layout), it has it's own independent data. An application usually consists of multiple loosely coupled activities. Those activities are held in an activity stack, where they are preserved to be used later without need to create them all over again. However, if the system needs memory, it clears the stack from the bottom (least recently used activities).

For communication between activities there are so called Intents. An intent is the main concept of communication between two components. A component can be for example an activity or a service. Intent can contain simple data, such as primitive or serialized data.

Presentation is handled using XML layout descriptors, which contain information about View objects and their parameters. This allows to separate the actual code from the layout creation, which could help the GUI designed create a GUI without having to understand the Java language or the Android API.

As a relatively new concept, so called Fragment was created. It is similar to activity, however it is not a mandatory component. It can be used as a controller for certain functionality area. It's advantage is that a developer can create separate Fragments with separate area of concern and display one or many of those based on the screen size. The typical use-case example can be a list of items and a detail of a selected item. On small screens, two Activities containing a single Fragment each will be needed, while on larger screens one activity can contain both Fragments.

\label[analysis.android_platform.material_design]
\secc Material design

Describe scrolling lists

%------------------------------------------------------------------------ GUI ----------------------------------------------------------------------%
\label[analysis.gui]
\sec GUI TODO


\label[analysis.gui.basic_principles]
\secc Basic principles

As the main tool of communication between an application and it's user, user interface must follow one basic rule -- the user goes first. UI is about the user, he must have a good feeling when using the application. He must understand what to do and how to do it. Therefore there are four rules a proper UI must obey:
\begitems
* {\bf Clear} -- it must be obvious what and where the user can control,
* {\bf Effective} -- minimizing the required user interactions for certain (requested) thing to happen,
* {\bf Foolproof} - avoiding the errors before they happen,
* {\bf Pleasant} - no stress when working with the UI, pleasant colors, contrast, good readability.
\enditems

Those rules might seem too shallow. That is why there are certain subgoals which are more specific, helping to achieve the main four goals. Those subgoals are the following seven:
\begitems
* {\bf Minimality} -- removing everything that can be removed without losing the requested information value,
* {\bf Responsiveness} -- giving the user a proper feedback, so that he knows something is happening,
* {\bf Forgiveness} -- letting the user make mistakes, allowing him to fix them, for example undo button or prompt message,
* {\bf Familiarity} -- using familiar, commonly used metaphors, icons, procedures,
* {\bf Consistency} -- using consistent visual and interaction language,
* {\bf Integration} -- using platform specific elements and rules
* {\bf Simplicity} - allowing user to quickly learn how to use the UI
\enditems

sources:
\begitems
* MI-NUR \url{https://edux.fit.cvut.cz/courses/MI-NUR/lectures/start}
* Designing for indash automotive \url{http://revinity.com/?p=128 }
* UX design stackexchange \url{http://ux.stackexchange.com/questions/51968/what-ux-guidelines-should-one-keep-in-mind-when-designing-the-gui-for-a-automobi}         0
\enditems

\label[analysis.gui.ui_in_a_car_environment]
\secc UI in a car environment

When developing user interface for car, it adds a certain responsibility. The need for safety while using the UI becomes the main priority. Because of that, some aspects are more important than other. The most important are described later in this section.

\seccc Minimality

For minimizing the cognitive load, the must be as little information as possible at a certain time. The user must see what he wants to see on first sight without seeking the answer for too long. When minimizing the information displayed there is no confusion, minimizing the glance time.

\seccc Consistence

Supporting usability and shortness of learning curve, consistency allows user to remember one procedure and apply it successfuly in different sections of UI. It allows user to learn things just once.

\seccc Readability

Good readability is one of the condition for application to be pleasant to use. In case of car environment, however, the readability of information is not just pleasant, but critical. Allowing the user to see the information he needs to see in the shortest time possible is fatal when it comes to driving. Therefore the font has to be large enough for every driver to see.

\seccc Controls

When it comes to controlling an application in an environment such as car, it is required to consider certain aspects not present in other environments. The moving car prevents user from being precise when it comes to touch. Therefore, the controls must be large enough to be reliably selectable. 

\seccc Colors

While in other environment the user can usually control the device brightness, it is not as easy task while driving. Furthermore, blinding the user with too much light might be fatal. Therefore proper colors must be used. For example, dominance of white color might be visible well in the daylight, but might blind the user at the night time. Also, proper color contrast must be considered for good visibility and readability.

\seccc Responsiveness

Responsiveness is an important factor when it comes to pleasure of using an application, but when it comes to using it in a car, it becomes extremely important for safety as well. When the application is responsive, the user does not have to check the screen for progress so often or worse, wait for the progress looking at it continuously.


%	------------------------------------------------------------------------ Server ----------------------------------------------------------------------%
%\sec Server
%
%
%\secc Functionality
%
%
%\secc Data storage
%
%
%\secc Communication
%
%
%	------------------------------------------------------------------------ Development and support tools ----------------------------------------------------------------------%
\label[analysis.development_and_support_tools]
\sec Development and support tools TODO


\label[analysis.development_and_support_tools.ide]
\secc Development environment

While using text editor and command line is an option, for speed of development only Integrated Development Environments are considered. In the time of writing this text, there were two possibilities for Android development -- Eclipse and AndroidStudio.

\seccc Eclipse

Based on research by (\url{http://zeroturnaround.com/rebellabs/java-tools-and-technologies-landscape-for-2014/6/}), the Eclipse IDE is the most often used Java IDE. That is probably the reason why Google inc. suggested this IDE for Android development in early phase. However, Eclipse has lost Android development support in late 2014 (\url{http://www.zdnet.com/article/google-releases-android-studio-kills-off-eclipse-adt-plugin/}).

\seccc Android Studio

Released in 2014, Android Studio became the main platform for Android development. It is based on IntelliJ IDE and supported by Google. For that reason, it is an obvious choice for new applications to be developed in Android Studio.


\label[analysis.development_and_support_tools.vcs]
\secc Version control system

In a software development process, version is very important. Being able to go back to working version, or to develop new features while the main version is still working is priceless. Currently there are three main VCS worth considering (\url{http://www.sitepoint.com/version-control-software-2014-what-options/}). 

\seccc Subversion

Based on CVS, Subversion has a single repository where all the data are stored. This simplifies the backup of a whole project, because all the data are located in one place. This, however, creates possible threat of data loss when the central repository gets destroyed without backup.

Because of the central repository, Subversion allows read and write access controls for a every single location and have them enforced across the entire project, which can come in handy when developing in a large community, but it is usually not required when developing in a small team.


\seccc Mercurial TODO

\seccc Git TODO

\label[analysis.development_and_support_tools.tdd]
\secc Test driven development

Being one of the main development aproaches in the last decade, test driven development helps to develop the application quickly and fluently. The main idea of TDD is to create automatic tests before the actual application code. While this enforces the developer to think twice when creating tests, which makes him think about what he actually wants to achieve, it also helps against random errors in code. Having the application tested with every build also supports continuous integration, which is described later in this text. (TODO JUnit?)

\label[analysis.development_and_support_tools.ci]
\secc Continuous integration

{\it\uv{Continuous Integration is a software development practice where members of a team integrate their work frequently, usually each person integrates at least daily - leading to multiple integrations per day. Each integration is verified by an automated build (including test) to detect integration errors as quickly as possible.}} (Martin Fowler, \url{http://www.martinfowler.com/articles/continuousIntegration.html})

Continuous integration supports rapid application development while giving the much needed feedback, so that the developer can see and adjust the direction, which the application development takes. 

For simple CI practice integration, there are several online services. For this particular application development, Travis system was chosen (TODO link \url{https://travis-ci.org/}). While offering usual CI functionality, it also integrates easily with GitHub and Gradle build system. 

%	------------------------------------------------------------------------ On-Board Diagnostics ----------------------------------------------------------------------%
\label[analysis.obd]
\sec On-Board Diagnostics TODO

On-Board Diagnostics states for a self-diagnostic equipment requirements for automotive vehicles. The modern implementations offer standardized communication port to provide real-time data as well as diagnostic trouble codes. The full specifications are explained in ISO 15031 (TODO fix). Some of them will be discussed later in the text.

Currently there are two versions of OBD. The first one (OBD I) provides only diagnostic trouble codes. The second one (OBD II) adds real-time vehicle data. The third version (OBD III) is currently being developed. It should support so called "remote OBD", which would broadcast the data to other vehicles, which could prevent collisions by warning the drivers when something bad happens suddenly. 

\label[analysis.obd.api]
\secc API TODO


\label[analysis.obd.data]
\secc Data TODO


%------------------------------------------------------------------------ DESIGN ------------------------------------------------------------------------%
\label[design]
\chap Design TODO


%	------------------------------------------------------------------------ Application architecture ----------------------------------------------------------------------%
\label[design.application_architecture]
\sec Application architecture TODO

Designing proper application architecture is one of the main and most challanging tasks in development process. Changing the architecture in to future proves to be one of the most expensive changes as for manhours (TODO link Code Complete?). Application architecture influences data flow, communication amongst components and overall application performance, as well as extensibility and possibility to change or add features in the future. While Android application architecture enforces certain components and platform features to be used, the is still space for diversity.

\label[design.application_architecture.platform_limitations]
\secc Platform limitations

As mentioned in Android platform analysis in section \ref[analysis-android_platform] on page \pgref[analysis-android_platform], the typical Android application consits of multiple Activities, which communicate with each other using Intents. While this approach supports the loosely coupled concept, it makes certain inter-cooperation rather difficult.  Sharing an object between activities usually means serializing the object or saving it to the database, which means deserializing or loading from database later. When striving for excellent performance, this can emerge into a real problem. As the Android platform does not allow database IO operations on the main presentation thread, it requires background thread with callbacks to the main one and screen revalidation when such callback occurs. It is critical to avoid such delays as much as possible, when comes to car environment where rapid reactions are required.

\label[design.application_architecture.extensibility]
\secc Extensibility

With the current rapid application development there is a need to be able to adjust based on market requirements. While creating a new application with every feature is a possibility, it is certainly better to be able to add new features to the old application so that is actually never becomes old. Extensibility is one of the main requirements for many reasons. When it comes to application developed in this thesis (TODO name?), new features are planned to be added based on user feedback. Therefore the architecture must be prepared to be easily extendable.

The main approach to achieve proper extensibility should be to write a clean code, which can prove to be a good idea when considering nearly every part of implementation process. Also the modularity concept is very usefull when it comes to extensibility and it will be discussed in section \ref[design.application_architecture.modularity].

\label[design.application_architecture.modularity]
\secc Modularity TODO

\seccc Note for Android platform limitations

The first considered approach was to create requirements on modules, such as manifest file as a descriptor and an implementation file with source codes and resources, so that the modules could be loaded dynamically and the extensions could be customizable. Then a user-base could develop modules on their own and add them freely into the application once they meet the requirements.

However, the Android concept with XML layouts does not allow their inflating during runtime. Because it is a performance-expensive operation, it pre-processes a XML file when building the application, as quoted below.

{\it\uv{For performance reasons, view inflation relies heavily on pre-processing of XML files that is done at build time. Therefore, it is not currently possible to use LayoutInflater with an XmlPullParser over a plain XML file at runtime.}} (TODO andoid layoutinflater documentation and quotes) 

\seccc Overview 

Modularity concept allows application to contain certain modules, each offering certain functionality based on some predefined requirements. 

\label[design.application_architecture.adaptability]
\secc Adaptability

Because the space on the screen is limited and also unknown (multiple devices have varying screen sizes) and every user might want to see different kind of information, he must be able to modify the layout, to choose the information he wants to see. The application must be adaptable to user's needs and requirements, so that he can control the application fluently and spend as little time as possible seeking the requested information.

For that reason there will be module containers which can contain multiple modules. User then selects the module for each container and selects a single container to be displayed at a time. This allows to build custom module sets for greater adaptibility. 

\label[design.application_architecture.android_auto_preparation]
\secc Android Auto preparation TODO




%	------------------------------------------------------------------------ GUI ----------------------------------------------------------------------%
\label[design.gui]
\sec GUI TODO

Given the car environment, designing proper graphics user interface is crucial for an in-car application. Not only it has to look good, it also has to consider safety issues, such as minimizing the cognitive load and required glance time to control the application or to read displayed information. To achieve that the GUI should follow the principles mentioned in chapter (TODO link).

\label[design.gui.basic_elements]
\secc Basic elements TODO

Basic idea

\label[design.gui.drafts]
\secc Drafts TODO

\label[design.gui.the_early_phase]
\secc The early phase TODO

In the early phase of the design process, the main idea was to display single piece of information as a time. Given that, a certain concept was created with a single application panel per screen, which would be a scrollable list. Swiping left or right would change the focus to another application panel. Part of the previous and following application panel would be seen, as shown on image (TODO link and image \#1).

This concept was recreated into a similar concept with difference in size of previous and following application panels. Those panels would be moved into the background which would make them smaller, as shown on image (TODO link and image \#2), however, more of those panels could be visible letting the user know more about the actual structure. Also, it presents combination of a name and an icon for easier recognizability.

For both drafts the following would apply. The swipe action would invoke text-to-speech action telling user the name of selected panel. This could lower the need to look at the application screen while driving. Also, all the panels would have different colors making them recognizable on first sight. The touch on an application panel would invoke the related application. This could be a music player, a map, etc. Examples of a music player subapplication are shown on images (TODO \#3 \#4) in the additional (TODO PRILOHA?). An early implementation is shown in the additional as well (TODO link).

\seccc Advantages

\begitems
* {\bf Readability} -- given a single panel per screen with only a name and icon in it, the font can be large enough to be properly readable.
* {\bf Colors} -- colors can distinguish separate applications panels making them easily recognizable, once the user learns the colors for each application.
\enditems

\seccc Disadvantages

\begitems
* {\bf Consistency} -- however is the main screen consistent, the~invoked subapplications are not. The concept does not force them to be, neither it gives a~clue about how they should look.
* {\bf Limited} -- the main screen has a limited functionality (near to none) while the layout of subapplications would have to be created independently everytime a~new feature is implemented. This also limits easy extensibility, as creating a~proper GUI is not a~simple task with the given constraints.
\enditems

\label[design.gui.the_second_phase]
\secc The second phase TODO

Next step was to fix the problems mentioned above. Being inspired by the reviewed applications (TODO link to section) one attempt ended with concept shown on image (TODO link \#5). It presents a vertical list of applications displayed in a column on the right side of the screen instead of horizontal list over whole screen. The main area contains the usual car data such as speed, rpm and consumption.

The second image (TODO link \#6) shows possibility of inserting a subapplication screen between application list and car data, for example a navigation. Also, it presents the concept of micro-controls in application list. It would allow a single control button to be displayed on an application panel such as pausing the song or silencing the radio. 

\seccc Advantages

\begitems
* {\bf Controls} -- the concept shows improvement in consistent functionality for displayed application panels which eases the control.
\enditems

\seccc Disadvantages

\begitems
* {\bf Minimality} -- the amount of data grows and it appears to be too much. There are different kinds of data displayed at the same time.
* {\bf Consistency} -- the vertical application list is consistent, however, the central panel is still suffering from lack of consistency, as every sub-application can have a different layout.
\enditems

\label[design.gui.the_grid]
\secc The grid

The next step towards consistency and space usage was to create a grid. This grid would be adjustable based on screen size, displaying the proper amount of application panels for given device. As shown on image (TODO link \#7), it is just an extension of preveously shown vertical list making it vertical and horizontal -- two dimensional.

Adding functionality to this grid, a new card concept emerged. It would consist of cards, which would provide additional information as well as control elements (as shown on image (TODO link \#8)). They would be active demoversion of the full application, which would be invoked by touch to the upper area of the card.


\seccc Advantages

\begitems
* {\bf Accsessible functionality} -- the concept shows available basic functionality without the need to invoke full application. This allows the user to remain in the main screen in most cases.
\enditems

\seccc Disadvantages

\begitems
* {\bf Controls} -- in order to fit in the card area, the controls might prove to be too small, which makes it difficult to touch them
* {\bf Readability} -- in order to fit in the card area, the text might have to be too small, which makes it difficult to read 
\enditems

\label[design.gui.the_final_design]
\secc The final design

Because every of the previously mentioned designs had at least one critical disadvantage, a new approach had to be taken. Because of consistency, every element must be specified. But considering the need for simplicity, there must be very limited amount of those elements.

Given the requirements for both consistency and simplicity, as well as extensible functionality, the elements are divided into two groups: those, that display information and those, that control the application. The simpliest way appeared to be the following: one element serves as a displayer, which displays one and only one kind of information, and the second element servers as a control button, which allows user to perform a single action. Every kind of functionality appears to be achievable by those elements or by sets of those elements.

Also, for improved adaptability a hierarchy model was considered, which makes it possible to create independent sets of functionality using hiearachical model, which supports the consistency and simplicity by repeating the same pattern in distinct areas.

As shown on image (TODO link \#11), the display panel consists of a name, an icon, a value and a unit. The control button is more simple, it consists of a name and an icon. An icon serves as a checkpoint for eyes to seek out the requested information quickly.

The idea is to have several screens containing several application panels (where amount of panels is based on screen size) with changing the screen by swiping left or right. As mentioned in section \ref[analysis.android_platform.material_design] on page \pgref[analysis.android_platform.material_design], Android suggests using vertically scrollable lists when presenting large sets of data. This can be suitable in most cases, however, in a car a user can easily swipe too heavily and scroll elsewhere and getting back to original place can put an unnecessary load on the driver's attention. Therefore there have to be separate pages, where one swipe changes a page by one.

\seccc Advantages

\begitems
* {\bf Minimality} -- only a single value is displayed per each panel,
* {\bf familiarity} -- using familiar (platform specific) icons should ease the information seeking process,
* {\bf consistency} -- consistent hierarchical model with only two types of elements,
* {\bf integration} -- using platform specific icons and specifics is a part of realization process,
* {\bf simplicity} -- again, there are only two kinds of elements, which is simple enough.
\enditems


Describe the process, phases, analyse and compare advantages, disadvantages, thoughts

%------------------------------------------------------------------------ REALIZATION ------------------------------------------------------------------------%
\label[realization]
\chap Realization TODO


%	------------------------------------------------------------------------ Preparation ----------------------------------------------------------------------%
\label[realization.preparation]
\sec Preparation TODO

While this thesis focuses on creating a tablet application, it's functionality could be shared amongst other Android platforms just by reflecting the differences. A possibility to extend application to a mobile or any other platform creates a need to divide a single project into two -- a core with shared functionality and a tablet project which focuses on tablet GUI and other specifics.

\label[realization.preparation.environment]
\secc Environment

As mentioned in analysis section \ref[analysis.development_and_support_tools.ide] on page \pgref[analysis.development_and_support_tools.ide], Android Studio IDE is used for code development. As it does not allow importing other project as a library, it requires a shared project to be registered as a module. This module has to be placed in a project subfolder and it is an Android Studio project of it's own. This is done by adding a new module and selecting a library module.


\label[realization.preparation.versioning]
\secc Versioning

Because of the workaround with a shared library in Android Studio, a special approach has to be taken. As Git supports submodules, a shared library has to be registered as one. This can be achieved by calling command {\tt git submodule add LIBRARY\_REPOSITORY\_URL} in the root project folder and then adding the library subfolder into the {\tt .gitignore} file.


\label[realization.preparation.testing]
\secc Testing TODO


\label[realization.preparation.scripting]
\secc Scripting TODO


%	------------------------------------------------------------------------ Tablet ----------------------------------------------------------------------%
\label[realization.tablet]
\sec Tablet specific TODO

While the Android API is shared across all Android platforms, it is the device size that is usually different. The GUI has to adapt based on the platform and therefore it's implementation differs. This section describes the tablet-related implementation using a shared library described in section \ref[realization.core].

\label[realization.tablet.activity]
\secc ModulePagerActivity

As mentioned in analysis section \ref[analysis.android_platform.architecture] on page \pgref[analysis.android_platform.architecture], an Activity is the basic component of every Android application. In this case, it is the only launch point of the application, it implements so called {\tt IModuleContext} interface described in section \ref[realization.core] on page \pgref[realization.core], which controls the interaction with modules (\ref[design.application_architecture.modularity]). Presentation of screen content is delegated to {\tt ModulePageFragment} (\ref[realization.tablet.fragment]).

While usually multiple activities are present in a single application, thanks to consistent hierarchical model a single activity class can be reused for multiple instances with different data. Which means that there is a single activity invoked per one requested set of modules.

\seccc Improvements

There are some improvements implemented for performance, battery consumption and hardware overloading prevention reasons, one of which is reacting to acitivity state by disabling inactive modules. Because of the independent module concept, modules display data on their own and they do not know when the data are requested. Therefore, the activity uses a list of those modules to deactive them when entering a paused or stopped state.

Also, sometimes it is required to restart the entire application, for example when some global changes need to be performed. As the Android architecture saves latest activities in a stack as mentioned in section \ref[analysis.android_platform.architecture] on page \pgref[analysis.android_platform.architecture], it is nessessary to clear this stack first, so that the OS does not backtrack to an old Activity. This is done by keeping control over existing activities and ending them one by one. This can also be used, when forcing the application to exit, as there is no proper option to end an application on Android platform from the application developer's view. 

\label[realization.tablet.fragment]
\secc ModulePageFragment

As mentioned in section \ref[analysis.android_platform.architecture] on page \pgref[analysis.android_platform.architecture] a Fragment can take over part of Activity's functionality. In this case a {\tt ModulePageFragment} handles the presentation of module set using a {\tt ModuleFragmentAdapter} (\ref[realization.tablet.adapter]) for obtaining the data and a custom layout {\tt GridLayout} (\ref[realization.tablet.gridlayout]) for displaying them in a grid.


\label[realization.tablet.adapter]
\secc ModuleFragmentAdapter

{\tt ModuleFragmentAdapter} follows the adapter concept, where extension of Android API class {\tt Adapter} is used to cover the access to list of data. This adapter gets a single {\tt ParentModule} (described in section \ref[realization.core.modules] on page \pgref[realization.core.modules]) and retrieves it submodules on demand.

\label[realization.tablet.gridlayout]
\secc GridLayout

Because the Android concept does not expect functionality required by this application, a library class {\tt android.widget.GridLayout} is not suitable for this situation. As mentioned in section \ref[design.gui.the_final_design] on page \pgref[design.gui.the_final_design], Android suggests the lists to be scrollable vertically. This is a functionality fully supported by {\tt android.widget.GridLayout} but unsuitable for the given use-case. It also makes it difficult to use this library class for the use-case described in section \ref[design.gui.the_final_design].

For reasons mentioned above a custom layout had to be created. Based on given measurements (of a module tile, a space) it computes amount of modules displayed per page and also their positions. Given the computed positions it then layouts all the provided modules.


%	------------------------------------------------------------------------ Core ----------------------------------------------------------------------%
\label[realization.core]
\sec Core TODO

The core contains all the functionality, it handles data, logic and also a standardized part of presentation, which consists of predefined single module veiws. Everything will be described in following text.
                        
\label[realization.core.modules]
\secc Modules TODO

As mentioned in section \ref[design.application_architecture.modularity]), there are so called modules, which handle the interaction between the application and it's user offering a single action or information. Together they can create multiple connected sets of functionality with consistent interface.

\label[realization.core.modules.imodule]
\seccc IModule

{\tt IModule} is an interface which covers the basic module functionality. It has to be implemented by every single module in order to achieve proper polymorfism. Using this approach, a tablet implementation can display a set of modules without knowing which module does what.

\label[realization.core.modules.abstractsimplemodule]
\seccc  AbstractSimpleModule

{\tt AbstractSimpleModule} is an abstract class which implements most of the {\tt IModule}'s functionality. It handles creating a unique Id for every module, which will be described later in section \ref[realization.core.data]. It also handles common module events and overrides simple methods to ease the implementation of a new module, which does not need those methods. Every other module extends this class.

\label[realization.core.modules.abstractparentmodule]
\seccc AbstractParentModule

For consistent hierarchical model, there has to be a module containing other module. This module extends the {\tt AbstractParentModule} class, which covers the module container functionality. Every instance of {\tt ModulePagerActivity} (\ref[realization.tablet.activity]) contains such container and displays it's content as a list of modules.

\label[realization.core.modules.abstractdisplaymodule]
\seccc AbstractDisplayModule

Displaying information is one of the most important goals of the developed application. {\tt AbstractDisplayModule} is the base class to be extended by modules displaying information. It handles updating the displayed value on request.

\label[realization.core.modules.abstracttimedupdatedisplaymodule]
\seccc AbstractTimedUpdateDisplayModule

{\tt AbstractTimedUpdateDisplayModule} serves as an extension to {\tt AbstractDisplayModule} handling automatic timed updates. It uses advanced genericity to offer multiple update modes for extending modules. Such mode states the frequency of calling the {\tt getUpdatedValue} method, which is to be implemented by subclasses. An optimization is implemented for this process, as {\tt getUpdatedValue} can invoke a long-lasting process. The last value is saved for further use by the {\tt updateValue} method, while the {\tt getUpdateValue} method merely updates this last value when it is done.

\label[realization.core.modules.abstractshortcutmodule]
\seccc AbstractShortcutModule

As mentioned in section \label[analysis.android_platform.architecture], there is an Intent as a mean of communication. This Intent is able to invoke an Activity, a Service and many other things. It can also invoke Activity of a different application installed on the device, which launches the application. The {\tt AbstractShortcutModule} handles invoking a custom Intent.

%As an extension to application functionality there is an option to invoke external applications as well. The {\tt AbstractShortcutModule} has a functionality of a shortcut to such external application. The developed application can then act as an application launcher optimized for in-car usage.

\seccc Other modules

There are several implementations of the modules mentioned above. A few will be shortly described in the following list:

\begitems
  \item {\bf SimpleShortcutModule} A mere implementation of {\bf AbstractShortcutModule} class (\ref[realization.core.modules.abstractshortcutmodule])
  \item {\bf SimpleParentModule} A mere implementation of {\bf AbstractParentModule} class  (\ref[realization.core.modules.abstractparentmodule])
  \item {\bf AppShortcutModule} An extension to {\bf AbstractShortcutModule} which limits to Intents invoking other installed application, therefore the (TODO name) developed application can server as an application launcher optimized for in-car usage 
  \item {\bf EmtpyModule} An empty module meant to be swapped for a different one, occupying an empty space
  \item {\bf BackModule} A module handling the back button, which can be pressed to get back to upper parent module (go up in the hierarchy)
  \item {\bf LightButtonModule} A module created for IoT support, offering a way to turn a given light on or off
  \item {\bf ObdRpmModule} A module communicating with the OBD and displaying information about current RPM of the vehicle
  \item {\bf ObdSpeedModule} A module communicating with the OBD and displaying information about current speed of the vehicle
\enditems 

\label[realization.core.modules.imodulecontext]
\seccc IModuleContext

An interface to be implemented by the Activity which should display the modules. It provides functionality to go up or down in module hierarchy, to toggle quick menu (\ref[realization.core.modules.quick_menu]) for a certain module or to gain access to resources.

\label[realization.core.modules.quick_menu]
\seccc Quick menu

A quick menu serves as a quick options menu for a simple module. Every module can invoke such quick menu. Usually it contains cancel, edit and delete options. It might contain other options specified by the given module.                                                                           

\label[realization.core.application]
\secc Application

This section describes the application logic. While most of the logic is hidden in modules themselves, the communication across application components must be handled elsewhere.

\seccc UpdateApplication

{\tt android.app.Application} is the main class of Android architecture. There is a single instance of this class per application. For that reason, this class is extended and enhanced with creating and starting timers for timed updates. An instance of this extended class is to be used by the tablet implementation instead of the original {\tt android.app.Application}.

\seccc FastEventBus

The concept of event bus is to have publishers and subscribers. It is most suitable for timed events, which serve as a signal for modules to update themselves. However, it is not limited just for time updates. Most of the communication can be handled using the event bus. {\tt FastEventBus} offers such functionality while remaining as simple as possible for better performance.

\label[realization.core.application.obd]
\seccc OBD

While modules are as independent as possible, there are cases where a shared functionality is required. Communicating with the OBD protocol is relatively expensive and it would be inefficient to handle it separately. Therefore the communication is centered into a single subpackage, which handles the data retrieval using requests and saving the responses for later use. Every module displaying the OBD data can then ask this package for information and recieve it as quickly as possible.

Handling the OBD communication is done by background service which uses the (TODO OBD lib) library to send requests to the OBD and to recieve results. It sends requests based on tasks from a queue, where modules push their requests. This ensures that only currently needed information will be requeste, minimizing the load.

\label[realization.core.data_storage]
\secc Data storage TODO


\label[realization.core.communication]
\secc Communication TODO


\label[realization.core.optimization]
\secc Optimization TODO



%	------------------------------------------------------------------------ Modularity ----------------------------------------------------------------------%
\label[realization.modularity]
\sec Modularity TODO


\label[realization.modularity.requirements]
\secc Requirements TODO


\label[realization.modularity.integration]
\secc Integration TODO


%	------------------------------------------------------------------------ GUI ----------------------------------------------------------------------%
\label[realization.gui]
\sec GUI TODO

GUI implementation based on the design! Implementing modules, color, responsive effects

\label[realization.gui.common_elements]
\secc Common elements TODO

Hierarchical model, effects, submenus

\label[realization.gui.multiple_designs]
\secc Multiple designs TODO

Limited set of module types

%------------------------------------------------------------------------ TESTING ------------------------------------------------------------------------%
\label[testing]
\chap Testing TODO

Brag about TDD, CI and Simulator!

%	------------------------------------------------------------------------ Implementation ----------------------------------------------------------------------%
\label[testing.code]
\sec Code TODO

Describe testing code, common testing (look\&see, etc.)

\label[testing.code.unit_testing]
\secc Unit testing TODO

Unit testing on android, mention Test driven development, continuous integration, automatic tests, consider giving an example

\label[testing.code.integration_testing]
\secc Integration testing TODO

Instrumentation? Describe TDD, CI, automation

\label[testing.code.system_testing]
\secc System testing TODO

Server testing, consider removing

\label[testing.code.qualification_testing]
\secc Qualification testing TODO

Testing with users - consider section on its own - testing application as a whole thing

%	------------------------------------------------------------------------ GUI ----------------------------------------------------------------------%
\label[testing.gui]
\sec GUI TODO


\label[testing.gui.heuristic_testing]
\secc Heuristic testing TODO

Introduction, description

\seccc Evaluation TODO

sources:
\begitems
* \url{https://docs.google.com/document/d/1LAPqmYqe5LBE6vqWpi-rRYjHY1-zVPCzkFP2Gvh5i-Q/edit}
\enditems

\seccc Conclusion TODO

Did not have time to fix

\label[testing.gui.testing_with_users]
\secc Testing with users TODO


\seccc Usability testing TODO

Testing the application as a regular application. Is it understandable? Is it easy to control, to see data, to understand, to comprehend, to learn?


\seccc Simulator TODO

Describe the car simulator in Albertov.
DO NOT FORGET TO THANK THE DEPARTMENT OF DRIVING SMTHING, CVUT FD


\seccc Preparations TODO

Selecting the world models and preparing them for testing, installing EyeTracker cameras, installing WebCamera, preparing data gathering, designing scenarios

\seccc Course TODO

The testing itself, describing participants

\seccc Evaluation TODO

Evaluating results

%	------------------------------------------------------------------------ Summary ----------------------------------------------------------------------%
\label[testing.summary]
\sec Summary TODO


%------------------------------------------------------------------------ CONCLUSION ------------------------------------------------------------------------%
\label[conclusion]
\chap Conclusion TODO


%	------------------------------------------------------------------------ Assignment completion ----------------------------------------------------------------------%
\label[conclusion.assignment_completion]
\sec Assignment completion TODO


%	------------------------------------------------------------------------ Project life cycle ----------------------------------------------------------------------%
\label[conclusion.project_life_cycle]
\sec Project life cycle TODO


\label[conclusion.project_life_cycle.present]
\secc Present TODO


\label[conclusion.project_life_cycle.future]
\secc Future TODO


%	------------------------------------------------------------------------ Summary ----------------------------------------------------------------------%
\label[conclusion.summary]
\sec Summary TODO



\bye
